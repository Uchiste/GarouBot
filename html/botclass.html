<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>botclass API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>botclass</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">emoji=[&#39;🍜&#39;,&#39;🐙&#39;,&#39;🙉&#39;,&#39;🦑&#39;,&#39;🐨&#39;,&#39;🐶&#39;,&#39;🐱&#39;,&#39;🐭&#39;,&#39;🐼&#39;,&#39;🐰&#39;,&#39;🦄&#39;,&#39;🐔&#39;,&#39;🍗&#39;,&#39;🤡&#39;,&#39;💃&#39;,&#39;🍖&#39;]
import asyncio
from asyncio import streams
from asyncio import tasks
import random as random

from discord import channel, player
from discord.enums import VoiceRegion
from discord.ext.commands.errors import PartialEmojiConversionFailure

class Role:
    &#34;&#34;&#34;
    Role is representing all the different kind of possible Role
    (virtual class)
    Composed at least by
        name (String) : the name of the &#39;Role&#39;
        channel (class discord.TextChannel) : channel links to the player
        side (int) : 1 if the role is for the village, 0 if not
    &#34;&#34;&#34;
    def __init__(self) -&gt; None:
        pass

class Sorcière(Role):
    &#34;&#34;&#34;
    Represents the Witch &#39;Role&#39;
    Composed by :
        name (String): the name of the &#39;Role&#39;
        channel (class discord.TextChannel): channel links to the player
        side (int): 1 if the role is for the village, -1 if not, 0 if neutral
        heal (Boolean): True if the Witch steal has her heal potion
        kill (Boolean): True if the Witch steal has her death potion
    &#34;&#34;&#34;
    def __init__(self,channel):
        &#34;&#34;&#34;Initializes the Witch.
        The Witch starts with one heal and one death potions. She is with the Village

        Args:
            channel (class discord.TextChannel): channel links to the player
        &#34;&#34;&#34;
        self.name=&#34;Sorcière&#34;
        self.channel=channel
        self.heal=True
        self.kill=True
        self.side=1
        
    async def action(self,game,bot):
        &#34;&#34;&#34;start the turn of the Witch.
        The Witcher has maximum 3 possibilities:
        -Use heal potion to save the wolf&#39;s dead  [Can be done one time]
        -Use death potion to kill someone (She chooses the Player) [Can be done one time]
        -Do nothing

        Args:
            game (class Game): The current game party
            bot (class Bot): The current bot
            
        return: Nothing
        &#34;&#34;&#34;
        sorciere=None
        non_sorciere=[]
        mort_soso=[]
        players=game.players
        for player in players:
            if player.role.name==&#34;Sorcière&#34;:
                sorciere=player
            else:
                non_sorciere.append(player)
        
        if len(game.night_death)==1 and self.heal==True and self.kill==True:
            mort_loup=game.night_death[0].user
            mes=sorciere.user.mention+&#34; Salut sorcière ! Cette nuit, quelqu&#39;un va mourir. Il s&#39;agit de &#34;+mort_loup.name+&#34; tu as le choix entre:\n    ⚕️ la ressuciter\n    💀 tuer quelqu&#39;un\n    💤 ne rien faire&#34;
            message_sorciere=await self.channel.send(mes)
            await message_sorciere.add_reaction(&#39;⚕️&#39;)
            await message_sorciere.add_reaction(&#39;💀&#39;)
            await message_sorciere.add_reaction(&#39;💤&#39;)
            await message_sorciere.add_reaction(&#39;✅&#39;)
            
            choix=[]
            def checkSosoAction(reaction,user):
                if user == sorciere.user and reaction.message.id == message_sorciere.id and str(reaction.emoji) == &#39;✅&#39; :
                    return(True)
                return(False)
            try:
                await bot.wait_for(&#34;reaction_add&#34;, timeout=1*60, check=checkSosoAction)
                cache_msg = await message_sorciere.channel.fetch_message(message_sorciere.id)
                i=-1
                for reactions in cache_msg.reactions:
                    i=i+1
                    user_list = [user async for user in reactions.users() if user != bot.user]
                    
                    for user in user_list:
                        if user==sorciere.user and i &lt; 3:
                            choix.append(i)
            except asyncio.TimeoutError:
                await self.channel.send(&#34;Le temps est dépassé, le choix sera aléatoire&#34;)
                choix=[random.randint(0,2)]
            if len(choix) !=1:
                choix=[random.randint(0,2)]
                await self.channel.send(&#34;C&#39;est interdit, le choix sera aléatoire&#34;)
            if choix[0]== 0:#on sauve
                game.night_death.pop(0)
                self.heal=False
                await self.channel.send(&#34;Tu es une personne bien, la victime survivra.&#34;)
            elif choix[0] == 1: #on tue
                message=&#34;Tu veux donc tuer quelqu&#39;un, qui va devoir boire ta fameuse potion ??:\n&#34;
                i=0
                for j in non_sorciere:
                    message=message+ emoji[i] + j.user.name+&#39;\n&#39;
                    i=i+1
                message_sorciere = await self.channel.send(message)
        
                for j in range(0,i):
                    await message_sorciere.add_reaction(emoji[j])
                await message_sorciere.add_reaction(&#39;✅&#39;)
                try:
                    await bot.wait_for(&#34;reaction_add&#34;, timeout=1*60, check=checkSosoAction)
                except asyncio.TimeoutError:
                    await self.channel.send(&#34;Le temps est dépassé, le choix sera aléatoire&#34;)
                    mort_soso.append(random.randint(0,len(non_sorciere)))
                cache_msg = await message_sorciere.channel.fetch_message(message_sorciere.id)
                i=-1
                for reactions in cache_msg.reactions:
                    i=i+1
                    user_list = [user async for user in reactions.users() if user != bot.user]
                    
                    for user in user_list:
                        if user == sorciere.user and i &lt; len(non_sorciere):
                            mort_soso.append(i)
                if (len(mort_soso)!=1):
                    mort_soso.append(random.randint(0,len(non_sorciere)))
                mort_soso=non_sorciere[mort_soso[0]]
                await self.channel.send(&#34;Très bien, &#34;+mort_soso.user.name+&#34; va mourir&#34;)
                self.kill=False
        elif len(game.night_death)==1 and self.heal==True and self.kill==False:
            mort_loup=game.night_death[0].user
            mes=sorciere.user.mention+&#34; Salut sorcière cette nuit, quelqu&#39;un va mourir. Il s&#39;agit de **&#34;+mort_loup.name+&#34;** tu as le choix entre:\n    ⚕️ la ressuciter\n    💤 ne rien faire&#34;
            message_sorciere=await self.channel.send(mes)
            await message_sorciere.add_reaction(&#39;⚕️&#39;)
            await message_sorciere.add_reaction(&#39;💤&#39;)
            await message_sorciere.add_reaction(&#39;✅&#39;)
            
            choix=[]
            def checkSosoAction(reaction,user):
                if user == sorciere.user and reaction.message.id == message_sorciere.id and str(reaction.emoji) == &#39;✅&#39; :
                    return(True)
                return(False)
            try:
                await bot.wait_for(&#34;reaction_add&#34;, timeout=1*60, check=checkSosoAction)
                cache_msg = await message_sorciere.channel.fetch_message(message_sorciere.id)
                i=-1
                for reactions in cache_msg.reactions:
                    i=i+1
                    user_list = [user async for user in reactions.users() if user != bot.user]
                    
                    for user in user_list:
                        if user==sorciere.user and i &lt; 2:
                            choix.append(i)
            except asyncio.TimeoutError:
                await self.channel.send(&#34;Le temps est dépassé, le choix sera aléatoire&#34;)
                choix=[random.randint(0,1)]
            if len(choix) !=1:
                choix=[random.randint(0,1)]
                await self.channel.send(&#34;C&#39;est interdit, le choix sera aléatoire&#34;)
            if choix[0]== 0:#on sauve
                un_mort_loup=False
                await self.channel.send(&#34;Tu es une personne bien, la victime survivra.&#34;)
                self.heal=False
        elif self.kill == True:
            mes=sorciere.user.mention+&#34; Salut sorcière, tu as le choix entre:\n    💀 tuer quelqu&#39;un\n    💤 ne rien faire&#34;
            message_sorciere=await self.channel.send(mes)
            await message_sorciere.add_reaction(&#39;💀&#39;)
            await message_sorciere.add_reaction(&#39;💤&#39;)
            await message_sorciere.add_reaction(&#39;✅&#39;)
            
            choix=[]
            def checkSosoAction(reaction,user):
                if user == sorciere.user and reaction.message.id == message_sorciere.id and str(reaction.emoji) == &#39;✅&#39; :
                    return(True)
                return(False)
            try:
                await bot.wait_for(&#34;reaction_add&#34;, timeout=1*60, check=checkSosoAction)
                cache_msg = await message_sorciere.channel.fetch_message(message_sorciere.id)
                i=-1
                for reactions in cache_msg.reactions:
                    i=i+1
                    user_list = [user async for user in reactions.users() if user != bot.user]
                    
                    for user in user_list:
                        if user==sorciere.user and i &lt; 2:
                            choix.append(i)
            except asyncio.TimeoutError:
                await self.channel.send(&#34;Le temps est dépasser, le choix sera aléatoire&#34;)
                choix=[random.randint(0,1)]
            if len(choix) !=1:
                choix=[random.randint(0,1)]
                await self.channel.send(&#34;C&#39;est interdit, le choix sera aléatoire&#34;)
            if choix[0] == 0: #on tue
                message=&#34;Tu veux donc tuer quelqu&#39;un, qui va devoir boire ta fameuse potion ??:\n&#34;
                i=0
                for j in non_sorciere:
                    message=message+ emoji[i] + j.user.name+&#39;\n&#39;
                    i=i+1
                message_sorciere = await self.channel.send(message)
        
                for j in range(0,i):
                    await message_sorciere.add_reaction(emoji[j])
                await message_sorciere.add_reaction(&#39;✅&#39;)
                
                try:
                    await bot.wait_for(&#34;reaction_add&#34;, timeout=1*60, check=checkSosoAction)
                except asyncio.TimeoutError:
                    await self.channel.send(&#34;Le temps est dépassé, le choix sera aléatoire&#34;)
                    mort_soso.append(random.randint(0,len(non_sorciere)))
                cache_msg = await message_sorciere.channel.fetch_message(message_sorciere.id)
                i=-1
                for reactions in cache_msg.reactions:
                    i=i+1
                    user_list = [user async for user in reactions.users() if user != bot.user]
                    
                    for user in user_list:
                        if user == sorciere.user and i &lt; len(non_sorciere):
                            mort_soso.append(i)
                if (len(mort_soso)!=1):
                    mort_soso.append(random.randint(0,len(non_sorciere)))
                mort_soso=non_sorciere[mort_soso[0]]
                await self.channel.send(&#34;Très bien, &#34;+mort_soso.user.name+&#34; va mourir&#34;)
                self.kill=False
                game.night_death.append(mort_soso)
        await self.channel.send(&#34;Bonne nuit la sorcière&#34;)
    
    async def jour(self,channel_public_place,user):
        &#34;&#34;&#34;set the role for the day
        The Witch can speak during the day in the public channel

        Args:
            channel_public_place (class discord.TextChannel): the public channel of the current game
            user (class discord.User): The user concerned
        &#34;&#34;&#34;
        await channel_public_place.set_permissions(user,read_messages=True,send_messages=True)

class Villageois(Role):
    &#34;&#34;&#34;
    Represents the Villager &#39;Role&#39;
    Composed by :
        name (String): the name of the &#39;Role&#39;
        channel (class discord.TextChannel): channel links to the player
        side (int): 1 if the role is for the village, -1 if not, 0 if neutral
    &#34;&#34;&#34;
    
    def __init__(self,channel):
        &#34;&#34;&#34;Initializes the Villager.
        He is with the Village

        Args:
            channel (class discord.TextChannel): channel links to the player
        &#34;&#34;&#34;
        self.name=&#34;Villageois&#34;
        self.channel=channel
        self.side=1
    async def jour(self,channel_public_place,user):
        &#34;&#34;&#34;set the role for the day
        The Villager can speak during the day in the public channel

        Args:
            channel_public_place (class discord.TextChannel): the public channel of the current game
            user (class discord.User): The user concerned
        &#34;&#34;&#34;
        await channel_public_place.set_permissions(user,read_messages=True,send_messages=True)

class Loup(Role):
    &#34;&#34;&#34;
    Represents the Wolf &#39;Role&#39;
    Composed by :
        name (String): the name of the &#39;Role&#39;
        channel (class discord.TextChannel): channel links to the player
        side (int): 1 if the role is for the village, -1 if not, 0 if neutral
    &#34;&#34;&#34;
    
    def __init__(self,channel):
        &#34;&#34;&#34;Initializes the Wolf.
        He is against the Village

        Args:
            channel (class discord.TextChannel): channel links to the player
        &#34;&#34;&#34;
        self.name=&#34;Loup&#34;
        self.channel=channel
        self.side=-1
    async def jour(self,channel_public_place,user):
        &#34;&#34;&#34;set the role for the day
        The Wolf can speak during the day in the public channel. But I can&#39;t speak in his specific channel

        Args:
            channel_public_place (class discord.TextChannel): the public channel of the current game
            user (class discord.User): The user concerned
        &#34;&#34;&#34;
        await self.channel.set_permissions(user,read_messages=True,send_messages=False)
        await channel_public_place.set_permissions(user,read_messages=True,send_messages=True)
      
class Cupidon(Role):
    &#34;&#34;&#34;
    Represents the Cupidon &#39;Role&#39;
    Composed by :
        name (String): the name of the &#39;Role&#39;
        channel (class discord.TextChannel): channel links to the player
        side (int): 1 if the role is for the village, -1 if not, 0 if neutral
    &#34;&#34;&#34;
    
    def __init__(self,channel):
        &#34;&#34;&#34;Initializes Cupidon.
        He is with the Village

        Args:
            channel (class discord.TextChannel): channel links to the player
        &#34;&#34;&#34;
        self.name=&#34;Cupidon&#34;
        self.channel=channel
        self.power=True
        self.side=1
    async def action(self,cupidon,game,bot):
        &#34;&#34;&#34;start the turn of Cupidon.
        He chooses a couple at the begining of the game
        Args:
            game (class Game): The current game party
            bot (class Bot): The current bot
            
        return: Nothing
        &#34;&#34;&#34;
        if self.power==True:
            self.power=False
            players=game.players
            #on demande à cupidon qui mettre en couple
            message=&#34;&#34;
            i=0
            for player in players:
                message=message+ emoji[i] + player.user.name+&#39;\n&#39;
                i=i+1
    
            message_cupidon=await self.channel.send(cupidon.user.mention+&#34;! Salut Cupidon, tu dois choisir qui va être amoureux parmi:\n&#34;+message)
            def checkCupidon(reaction,user):
                if user==cupidon.user and reaction.message.id == message_cupidon.id and (str(reaction.emoji) == &#39;✅&#39; or str(reaction.emoji) ==&#39;❌&#39;):
                    return(True)
                return(False)

            for j in range(0,i):
                await message_cupidon.add_reaction(emoji[j])
            await message_cupidon.add_reaction(&#39;✅&#39;)
            couple=[]
            try:
                await bot.wait_for(&#34;reaction_add&#34;, timeout=60, check=checkCupidon)
                cache_msg = await message_cupidon.channel.fetch_message(message_cupidon.id)
                i=-1
                for reactions in cache_msg.reactions:
                    i=i+1
                    user_list = [user async for user in reactions.users() if user != bot.user]
                    
                    for user in user_list:
                        if user==cupidon.user and i &lt; len(players):
                            couple.append(players[i])
            except asyncio.TimeoutError:
                await self.channel.send(&#34;Le temps est dépassé, le choix sera aléatoire&#34;)
                couple.append(players[random.randint(0,len(players)-1)])
                jalea=players[random.randint(0,len(players)-1)]
                while jalea.user == couple[0].user:
                    jalea=players[random.randint(0,len(players)-1)]
                couple.append(jalea)
            if len(couple) !=2:
                await self.channel.send(&#34;Erreur dans la saisie, le choix est aléatoire&#34;)
                couple.append(players[random.randint(0,len(players)-1)])
                jalea=players[random.randint(0,len(players)-1)]
                while jalea.user == couple[0].user:
                    jalea=players[random.randint(0,len(players)-1)]
                couple.append(jalea)
            mes=&#34;Le couple est composé de &#34;+couple[0].user.name + &#34; et &#34;+ couple[1].user.name
            await self.channel.send(mes)
            print(couple)
            channel_lover=await game.category.create_text_channel(&#34;Amoureux&#34;)
            game.def_lover(Lover(couple[1],couple[0],channel_lover))
            await channel_lover.set_permissions(couple[1].user,read_messages=True,send_messages=True)
            await channel_lover.set_permissions(couple[0].user,read_messages=True,send_messages=True)
            await channel_lover.send(&#34;Salut &#34;+couple[1].user.mention+&#34; et &#34;+couple[0].user.mention+&#34; askip vous êtes en couple ;) !&#34;)
    async def jour(self,channel_public_place,user):
        &#34;&#34;&#34;set the role for the day
        Cupidon can speak during the day in the public channel.

        Args:
            channel_public_place (class discord.TextChannel): the public channel of the current game
            user (class discord.User): The user concerned
        &#34;&#34;&#34;
        await channel_public_place.set_permissions(user,read_messages=True,send_messages=True)

class Voyante(Role):
    &#34;&#34;&#34;
    Represents the Clairvoyant &#39;Role&#39;
    Composed by :
        name (String): the name of the &#39;Role&#39;
        channel (class discord.TextChannel): channel links to the player
        side (int): 1 if the role is for the village, -1 if not, 0 if neutral
    &#34;&#34;&#34;
    
    def __init__(self,channel):
        &#34;&#34;&#34;Initializes Clairvoyant.
        He is with the Village

        Args:
            channel (class discord.TextChannel): channel links to the player
        &#34;&#34;&#34;
        self.name=&#34;Voyante&#34;
        self.channel=channel
        self.side=1
    async def action(self,voyante,game,bot):
        &#34;&#34;&#34;start the turn of Clairvoyant.
        She can discover the role of one Player each nigth
        Args:
            game (class Game): The current game party
            bot (class Bot): The current bot
            
        return: Nothing
        &#34;&#34;&#34;
        non_voyante=[]
        players=game.players
        for player in players:
            if player != voyante and player.is_alive:
                non_voyante.append(player)
    
        message=&#34;&#34;
        i=0
        for player in non_voyante:
            message=message+ emoji[i] + player.user.name+&#39;\n&#39;
            i=i+1

        message_voyante=await self.channel.send(voyante.user.mention+&#34;! Salut Voyante, tu dois choisir qui tu veux voir cette nuit:\n&#34;+message)
        def checkVoyante(reaction,user):
            if user==voyante.user and reaction.message.id == message_voyante.id and (str(reaction.emoji) == &#39;✅&#39; or str(reaction.emoji) ==&#39;❌&#39;):
                return(True)
            return(False)

        for j in range(0,i):
            await message_voyante.add_reaction(emoji[j])
        await message_voyante.add_reaction(&#39;✅&#39;)
        vision=[]
        try:
            await bot.wait_for(&#34;reaction_add&#34;, timeout=60, check=checkVoyante)
        except asyncio.TimeoutError:
            await self.channel.send(&#34;Le temps est dépassé ou le choix est erroné, le choix sera donc aléatoire&#34;)
        cache_msg = await message_voyante.channel.fetch_message(message_voyante.id)
        i=-1
        
        for reactions in cache_msg.reactions:
            i=i+1
            user_list = [user async for user in reactions.users() if user != bot.user]
            
            for user in user_list:
                if user==voyante.user and i &lt; len(non_voyante):
                    vision.append(non_voyante[i])
        if len(vision) !=1:
            vision=[non_voyante[random.randint(0,len(non_voyante)-1)]]
        mes=&#34;Tu as décidé de voir &#34;+vision[0].user.name+ &#34; qui est &#34;+vision[0].role.name

        await self.channel.send(mes)
    async def jour(self,channel_public_place,user):
        &#34;&#34;&#34;set the role for the day
        Cupidon can speak during the day in the public channel.

        Args:
            channel_public_place (class discord.TextChannel): the public channel of the current game
            user (class discord.User): The user concerned
        &#34;&#34;&#34;
        await channel_public_place.set_permissions(user,read_messages=True,send_messages=True)

class Chasseur(Role):
    &#34;&#34;&#34;
    Represents the Hunter &#39;Role&#39;
    Composed by :
        name (String): the name of the &#39;Role&#39;
        channel (class discord.TextChannel): channel links to the player
        side (int): 1 if the role is for the village, -1 if not, 0 if neutral
    &#34;&#34;&#34;
    def __init__(self,channel):
        &#34;&#34;&#34;Initializes the Hunter.
        He is with the Village

        Args:
            channel (class discord.TextChannel): channel links to the player
        &#34;&#34;&#34;
        self.name=&#34;Chasseur&#34;
        self.channel=channel
        self.side=1
        self.power=True
    async def action(self,game,bot):
        &#34;&#34;&#34;start the turn of the Hunter.
        When he dies, he can kill someone else or do nothing
        Args:
            game (class Game): The current game party
            bot (class Bot): The current bot
            
        return: Nothing
        &#34;&#34;&#34;
        if self.power==True:
            self.power=False
            #je vais demander qui il veut tuer
            players=game.players
            chasseur=None
            targets=[]
            for player in players:
                if player.role.name!=self.name and player.is_alive():
                    targets.append(player)
                elif player.role.name==&#34;Chasseur&#34;:
                    chasseur = player
            message=&#34;Salut &#34;+chasseur.user.mention+&#34;,tu es mort, tu dois choisir qui va mourir ou ne rien faire:\n&#34;
            i=0
            for target in targets:
                message=message+ emoji[i] +&#34; &#34;+ target.user.name+&#39;\n&#39;
                i=i+1
            message_chasseur=await chasseur.role.channel.send(message)
            await message_chasseur.pin()
            for j in range(0,i):
                await message_chasseur.add_reaction(emoji[j])
            await message_chasseur.add_reaction(&#39;💤&#39;)
            await message_chasseur.add_reaction(&#39;✅&#39;)
            
            choice=[]
            def checkChasseur(reaction,user):
                if user == chasseur.user and reaction.message.id == message_chasseur.id and str(reaction.emoji) == &#39;✅&#39; :
                    return(True)
                return(False)
            try:
                await bot.wait_for(&#34;reaction_add&#34;, timeout=1*60, check=checkChasseur)
                cache_msg = await message_chasseur.channel.fetch_message(message_chasseur.id)
                i=-1
                for reactions in cache_msg.reactions:
                    i=i+1
                    user_list = [user async for user in reactions.users() if user != bot.user]
                    
                    for user in user_list:
                        if user.id ==chasseur.user.id and i &lt; len(targets)+1:
                            choice.append(i)
            except asyncio.TimeoutError:
                await chasseur.role.channel.send(&#34;Le temps est dépassé, le choix sera aléatoire&#34;)
                choice=[random.randint(0,len(targets))]
            if len(choice) !=1:
                choice=[random.randint(0,len(targets))]
                await chasseur.role.channel.send(&#34;C&#39;est impossible, le choix sera aléatoire&#34;)
            if choice[0] == len(targets):
                await chasseur.role.channel.send(&#34;Tu ne fais rien, tu es pacifiste.&#34;)
                return()
            mort=targets[choice[0]]
            #je tue
            await game.channel_public_place.send(&#34;Le chasseur a décidé de tirer sur &#34;+mort.user.mention)
            await game.channel_recap.send(&#34;Le chasseur a décidé de tirer sur &#34;+mort.user.mention)
            await mort.kill(game.channel_public_place,game.channel_graveyard,game.channel_recap,game.vivant,game.mort)
            await chasseur.role.channel.send(&#34;Tu as décidé de tuer &#34;+mort.user.name)
            #check cupidon
            await game.check_lover()
    async def jour(self,channel_public_place,user):
        &#34;&#34;&#34;set the role for the day
        The hunter can speak during the day in the public channel.

        Args:
            channel_public_place (class discord.TextChannel): the public channel of the current game
            user (class discord.User): The user concerned
        &#34;&#34;&#34;
        await channel_public_place.set_permissions(user,read_messages=True,send_messages=True)

class Petite_fille(Role):
    &#34;&#34;&#34;
    Represents the Little girl &#39;Role&#39;
    Composed by :
        name (String): the name of the &#39;Role&#39;
        channel (class discord.TextChannel): channel links to the player
        side (int) : 1 if the role is for the village, -1 if not, 0 if neutral
        deja_lu (int) : the last message read from the wolf&#39;s channel
    &#34;&#34;&#34;
    def __init__(self,channel):
        &#34;&#34;&#34;Initializes the Little girl.
        She is with the Village

        Args:
            channel (class discord.TextChannel): channel links to the player
        &#34;&#34;&#34;
        self.name=&#34;Petite Fille&#34;
        self.channel=channel
        self.side=1
        self.deja_lu=0
    async def action(self,game):
        &#34;&#34;&#34;start the turn of the Little girl.
        She can ask to know what the wolf are saying with the command &#39;!ecoute&#39;
        Args:
            game (class Game): The current game party
            
        return: Nothing
        &#34;&#34;&#34;
        players=game.players
        chan_loup=None
        for player in players:
            if player.role.name==&#34;Loup&#34;:
                chan_loup=player.role.channel
        if chan_loup==None:
            await self.channel.send(&#34;Il n&#39;y a pas de loup à écouter&#34;)
        else:
            messages=await chan_loup.history(limit = 1000).flatten()
            messages.reverse()
            loup=None
            for message in messages:
                if message.author.name != &#34;GarouBOT&#34;:
                    if message.id &gt; self.deja_lu:
                        if loup != message.author:
                                loup=message.author
                                await self.channel.send(&#34;```    Un loup dit:```&#34;)
                        await self.channel.send(message.content)  
            self.deja_lu=message.id
            print(&#34;ecoute fin&#34;)
            await self.channel.send(&#34;```Tu as tout entendu pour l&#39;instant```&#34;)
    async def jour(self,channel_public_place,user):
        &#34;&#34;&#34;set the role for the day
        The Little girl can speak during the day in the public channel.

        Args:
            channel_public_place (class discord.TextChannel): the public channel of the current game
            user (class discord.User): The user concerned
        &#34;&#34;&#34;
        await channel_public_place.set_permissions(user,read_messages=True,send_messages=True)

class Soeur(Role):
    &#34;&#34;&#34;
    Represents the Sister &#39;Role&#39;
    Composed by :
        name (String): the name of the &#39;Role&#39;
        channel (class discord.TextChannel): channel links to the player
        side (int) : 1 if the role is for the village, -1 if not, 0 if neutral
    &#34;&#34;&#34;
    def __init__(self,channel):
        &#34;&#34;&#34;Initializes the Sister.
        She is with the Village
        She can speak to her Sister during the night

        Args:
            channel (class discord.TextChannel): channel links to the player
        &#34;&#34;&#34;
        self.name=&#34;Soeur&#34;
        self.channel=channel
        self.side=1
    async def jour(self,channel_public_place,user):
        &#34;&#34;&#34;set the role for the day
        The Sister can speak during the day in the public channel.
        She can speak to her Sister during the night
    
        Args:
            channel_public_place (class discord.TextChannel): the public channel of the current game
            user (class discord.User): The user concerned
        &#34;&#34;&#34;
        await self.channel.set_permissions(user,read_messages=True,send_messages=False)
        await channel_public_place.set_permissions(user,read_messages=True,send_messages=True)

class Salvateur(Role):
    &#34;&#34;&#34;
    Represents the Salvateur&#39;
    Composed by :
        name (String): the name of the &#39;Role&#39;
        channel (class discord.TextChannel): channel links to the player
        side (int) : 1 if the role is for the village, -1 if not, 0 if neutral
        self.previous_night (class discord.user) : last personn he protected
    &#34;&#34;&#34;
    def __init__(self,channel):
        &#34;&#34;&#34;Initializes the Salvateur.
        He is with the Village
        He can protect every nigth someone (can&#39;t be the same personn two following night)

        Args:
            channel (class discord.TextChannel): channel links to the player
        &#34;&#34;&#34;
        self.name=&#34;Salvateur&#34;
        self.channel=channel
        self.side=1
        self.previous_night=None
    async def jour(self,channel_public_place,user):
        &#34;&#34;&#34;set the role for the day
        The Salvateur can speak during the day in the public channel.
        She can speak to her Sister during the night
    
        Args:
            channel_public_place (class discord.TextChannel): the public channel of the current game
            user (class discord.User): The user concerned
        &#34;&#34;&#34;
        await channel_public_place.set_permissions(user,read_messages=True,send_messages=True)
    async def action(self,game,bot):
        &#34;&#34;&#34;start the turn of the Salvateur.
        Choose someone to protect.
        
        Args:
            game (class Game): The current game party
            
        return: Nothing
        &#34;&#34;&#34;
        players_alive=[]
        salvateur=None
        players=game.players
        for player in players:
            if player.is_alive():
                if  player.role.name==&#34;Salvateur&#34;:
                    salvateur=player
                players_alive.append(player)
    
        message=&#34;&#34;
        i=0
        for player in players_alive:
            message=message+ emoji[i] + player.user.name+&#39;\n&#39;
            i=i+1

        message_voyante=await self.channel.send(salvateur.user.mention+&#34;! Salut Salvateur, tu dois choisir qui proteger cette nuit (pas deux fois de suite la même personne):\n&#34;+message)
        def checkVoyante(reaction,user):
            if user==salvateur.user and reaction.message.id == message_voyante.id and (str(reaction.emoji) == &#39;✅&#39; or str(reaction.emoji) ==&#39;❌&#39;):
                return(True)
            return(False)

        for j in range(0,i):
            await message_voyante.add_reaction(emoji[j])
        await message_voyante.add_reaction(&#39;✅&#39;)
        protect=[]
        try:
            await bot.wait_for(&#34;reaction_add&#34;, timeout=60, check=checkVoyante)
        except asyncio.TimeoutError:
            await self.channel.send(&#34;Le temps est dépassé ou le choix est erroné, le choix sera donc aléatoire&#34;)
        cache_msg = await message_voyante.channel.fetch_message(message_voyante.id)
        i=-1
        
        for reactions in cache_msg.reactions:
            i=i+1
            user_list = [user async for user in reactions.users() if user != bot.user]
            
            for user in user_list:
                if user==salvateur.user and i &lt; len(players_alive):
                    protect.append(players_alive[i])
        if len(protect) !=1:
            protect=[players_alive[random.randint(0,len(players_alive)-1)]]
        while protect[0] == self.previous_night: #on regarde si c&#39;est la meme personne que la nuit précedente
            await self.channel.send(&#34;Le choix est identique à la nuit précedente, on fait aléatoirement&#34;)
            protect=[players_alive[random.randint(0,len(players_alive)-1)]]
        
        #si il a proteger le mort alors on enleve le mort
        j=0
        print(&#34;protect =&#34;,protect[0])
        print(&#34;death =&#34;,game.night_death)
        for i in range (0,len(game.night_death)):
            if game.night_death[i-j] == protect[0]:
                game.night_death.pop(i-j)
                j+=1

        self.previous_night=protect[0]
        await self.channel.send(protect[0].user.name+&#34; va être protèger cette nuit !&#34;)


class Lover():
    &#34;&#34;&#34;
    Represents a couple 
    Composed by :
        channel (class discord.TextChannel): channel links to the couple
        player1 &amp; player2 (class discord.member) : which are the two member of the couple
    &#34;&#34;&#34;
    def __init__(self,player1,player2,channel):
        &#34;&#34;&#34;initializes the couple
        
        Args:
            channel (class discord.TextChannel): channel links to the couple
            player1 &amp; player2 (class discord.member) : which are the two member of the couple
        return: Nothing
        &#34;&#34;&#34;
        self.player1=player1
        self.player2=player2
        self.channel=channel
    async def check_death(self,channel_public_place,channel_graveyard,channel_recap,vivant,mort):
        &#34;&#34;&#34;This function check if one member of the couple is dead or not. If he is, the other member die too.

        Args:
            channel_public_place
            channel_graveyard
            channel_recap
            vivant : discord role (living person)
            mort : discord role (dead person)
        &#34;&#34;&#34;
        if not(self.player1.is_alive()) and self.player2.is_alive():
            await channel_public_place.send(self.player2.user.mention+&#34; était amoureux de &#34;+self.player1.user.mention)
            await channel_recap.send(self.player2.user.mention+&#34; était amoureux de &#34;+self.player1.user.mention)
            await self.player2.kill(channel_public_place,channel_graveyard,channel_recap,vivant,mort)
        elif self.player1.is_alive() and not(self.player2.is_alive()):
            await channel_public_place.send(self.player1.user.mention+&#34; était amoureux de &#34;+self.player2.user.mention)
            await channel_recap.send(self.player1.user.mention+&#34; était amoureux de &#34;+self.player2.user.mention)
            await self.player1.kill(channel_public_place,channel_graveyard,channel_recap,vivant,mort)
    async def nuit(self):
        &#34;&#34;&#34;set the couple for the night
        The couple can speak during the night in their own channel
        &#34;&#34;&#34;
        if self.player1.is_alive() and self.player2.is_alive():
            await self.channel.set_permissions(self.player1.user,read_messages=True, send_messages=True)
            await self.channel.set_permissions(self.player2.user,read_messages=True, send_messages=True)
    async def jour(self):
        &#34;&#34;&#34;set the couple for the night
        The couple can speak during the night in their own channel
        &#34;&#34;&#34;
        await self.channel.set_permissions(self.player1.user,read_messages=True, send_messages=False)
        await self.channel.set_permissions(self.player2.user,read_messages=True, send_messages=False)


        
class Joueur:
    &#34;&#34;&#34;represents a Player
    &#34;&#34;&#34;
    def __init__(self,user,role):
        &#34;&#34;&#34;sets the class with is role and the discord user
        The player start alive.

        Args:
            user
            role
        &#34;&#34;&#34;
        self.alive=True
        self.user=user
        self.role=role

    def is_alive(self):
        &#34;&#34;&#34;_summary_

        Returns:
            Bool : True if the player is alive / False if the player is dead
        &#34;&#34;&#34;
        return self.alive

    async def kill(self,channel_public_place,channel_graveyard,channel_recap,vivant,mort):
        &#34;&#34;&#34;Kill the player and uptodate his rigths

        Args:
            channel_public_place
            channel_graveyard
            channel_recap
            vivant : discord role 
            mort : discord role
        &#34;&#34;&#34;
        self.alive=False
        await channel_public_place.set_permissions(self.user, read_messages=True, send_messages=False)
        await self.role.channel.set_permissions(self.user, read_messages=True, send_messages=False)
        await channel_graveyard.set_permissions(self.user, read_messages=True, send_messages=True)
        await channel_public_place.send(self.user.mention+ &#34;est mort, iel était &#34;+self.role.name)
        await channel_recap.send(self.user.mention+ &#34;est mort, iel était &#34;+self.role.name)
        member=await channel_public_place.guild.fetch_member(self.user.id)
        await member.remove_roles(vivant,reason=None)
        await member.add_roles(mort,reason=None)

    async def nuit(self,channel_public_place):
        &#34;&#34;&#34;starts the nigth for the player

        Args:
            channel_public_place
        &#34;&#34;&#34;
        if self.alive==True:
            await self.role.channel.set_permissions(self.user,read_messages=True,send_messages=True)
            await channel_public_place.set_permissions(self.user,read_messages=True,send_messages=False)


class Game:
    &#34;&#34;&#34;represents a Game
    &#34;&#34;&#34;
    def __init__(self):
        self.started=False
        self.category=None
        self.channel_public_place=None
        self.channel_graveyard=None
        self.channel_polling=None
        self.players=None
        self.night_death=[]
        self.lover=None
        self.with_mayor=True
        self.mayor=None
        self.day=0

    def initialize(self,category,public_place,graveyard,polling,recap,players,vivant,mort):
        &#34;&#34;&#34;set all the parameters (specific to the discord&#39;s server)
        
        needs :
            category: class discord.CategoryChannel
            public_place: class discord.TextChannel
            graveyard: class discord.TextChannel
            polling: class discord.TextChannel
            recap: class discord.TextChannel
            players: list of players
            vivant: class discord.Role
            mort: class discord.Role
        &#34;&#34;&#34;
        self.category=category
        self.channel_public_place=public_place
        self.channel_graveyard=graveyard
        self.channel_polling=polling
        self.channel_recap=recap
        self.players=players
        self.vivant=vivant
        self.mort=mort
    
    def is_started(self):
        &#34;&#34;&#34;returns &#39;true&#39; if the game is already started / &#39;false&#39; if not
        &#34;&#34;&#34;
        return(self.started)
    def start(self):
        &#34;&#34;&#34;set started paramaters to true (the game is started)
        &#34;&#34;&#34;
        self.started=True
    def finish(self):
        &#34;&#34;&#34;uses at the end of the game
        &#34;&#34;&#34;
        print(&#34;PARTIE FINI&#34;)
        self.started=False
        self.channel_public_place=None
        self.channel_graveyard=None
        self.channel_polling=None
        self.players=None
        self.night_death=[]
        self.lover=None
        self.with_mayor=True
        self.mayor=None
    def def_lover(self,lover):
        &#34;&#34;&#34;set the couple
        &#34;&#34;&#34;
        self.lover=lover
    async def check_lover(self):
        &#34;&#34;&#34;checks if one member of the couple is dead or not
        &#34;&#34;&#34;
        if self.lover!=None:
            await self.lover.check_death(self.channel_public_place,self.channel_graveyard,self.channel_recap,self.vivant,self.mort)
    
    def without_mayor(self):
        self.with_mayor=False

    async def define_mayor(self,bot):
        &#34;&#34;&#34;does the election of the mayor

        Args:
            bot:  class discord.ClientUser
        &#34;&#34;&#34;
        if self.mayor == None and self.with_mayor==True:
            players_alive=[]
            users_alive=[]
            
            for player in self.players:
                if player.is_alive():
                    players_alive.append(player)
                    users_alive.append(player.user)
            await self.channel_public_place.send(&#34;Le vote pour le maire va commencer !!&#34;)
            message=&#34;&#34;
            i=0
            
            for player in players_alive:
                message=message+ emoji[i] + player.user.name+&#39;\n&#39;
                i=i+1
            message_place_publique=await self.channel_polling.send(&#34;la personne qui aura le plus grand nombre de vote sera maire, parmi:\n&#34;+message)
            for j in range(0,i):
                await message_place_publique.add_reaction(emoji[j])
            election=[0 for z in range(0,len(players_alive))]
            await asyncio.sleep(60)
            cache_msg = await self.channel_polling.fetch_message(message_place_publique.id)
            i=-1
            for reactions in cache_msg.reactions:
                i=i+1
                user_list = [user async for user in reactions.users() if user != bot.user]
                for user in user_list:
                    if user in users_alive and i &lt; len(users_alive):
                        election[i]+=1
            imax=[-1]
            vmax=0
            print(election)
            for z in range (0,len(players_alive)):
                if vmax == election[z]:
                    imax.append(z)
                elif vmax &lt; election[z]:
                    vmax=election[z]
                    imax=[z]
            mes=&#34;&#34;
            if imax[0]==-1:
                mes=&#34;Vous n&#39;avez choisi personne, le vote se fera aléatoirement\n&#34;
                rand=random.randint(0,len(players_alive)-1)
                maire=players_alive[rand]
                mes=mes+&#34;C&#39;est donc &#34;+maire.user.mention+&#34; qui sera maire&#34;
            elif len(imax) != 1:
                mes=&#34;Il y a égalité, le vote se fera aléatoirement parmi les heureux élus\n&#34;
                rand=random.randint(0,len(imax)-1)
                maire=players_alive[rand]
                mes=mes+&#34;C&#39;est donc &#34;+maire.user.mention+&#34; qui sera maire&#34;
            else:
                maire=players_alive[imax[0]]
                mes=&#34;Vous avez décidé d&#39;élire &#34;+maire.user.mention
            await self.channel_public_place.send(mes)
            await self.channel_polling.send(mes)
            await self.channel_recap.send(mes)
            self.mayor=maire

    async def check_mayor(self,bot):
        &#34;&#34;&#34;checks if the mayor is dead or not.
        If the mayor is dead, he will choose the next mayor. If he doesn&#39;t choose, the choice is random.

        Args:
            bot: class discord.ClientUser
        &#34;&#34;&#34;
        if self.mayor!= None and self.with_mayor==True:
            if self.mayor.is_alive()==False:
                players_alive=[]
                users_alive=[]
                for player in self.players:
                    if player.is_alive():
                        players_alive.append(player)
                        users_alive.append(player.user)
                await self.channel_public_place.send(&#34;Le maire est mort, un nouveau maire doit être choisi!&#34;)
                message=&#34;&#34;
                for j in range(0,len(players_alive)):
                    message=message+emoji[j]+users_alive[j].name+&#34;\n&#34;
                message_perso=await self.channel_polling.send(self.mayor.user.mention+&#34; choisis qui sera maire à ta place, parmi:\n&#34;+message)
                for j in range(0,len(players_alive)):
                    await message_perso.add_reaction(emoji[j])
                await message_perso.add_reaction(&#39;✅&#39;)
                fmaire=[]
                def checkMaire(reaction,user):
                    if reaction.message.id == message_perso.id and (str(reaction.emoji) == &#39;✅&#39;) and user.id==self.mayor.user.id:
                        return(True)
                    return(False)
                try:
                    await bot.wait_for(&#34;reaction_add&#34;, timeout=60, check=checkMaire)
                    cache_msg = await self.channel_polling.fetch_message(message_perso.id)
                    i=-1
                    for reactions in cache_msg.reactions:
                        i=i+1
                        user_list = [user async for user in reactions.users() if user != bot.user]
                        for user in user_list:
                            if user == self.mayor.user and i&lt;len(players_alive):
                                fmaire.append(players_alive[i])
                except asyncio.TimeoutError:
                    await message_perso.channel.send(&#34;Le temps est dépassé, le choix sera aléatoire&#34;)
                    fmaire=[players_alive[random.randint(0,len(players_alive)-1)]]
                if len(fmaire) !=1:
                    await message_perso.channel.send(&#34;Erreur dans la saisie, le choix est aléatoire&#34;)
                    fmaire=[players_alive[random.randint(0,len(players_alive)-1)]]
                maire=fmaire[0]
                mes=&#34;Le nouveau maire est &#34;+maire.user.mention
                await self.channel_polling.send(mes)
                await self.channel_public_place.send(mes)
                self.mayor=maire

    async def vote(self,bot):
        &#34;&#34;&#34;does the vote to select the player which will die.
        
        Args:
            bot: class discord.ClientUser
        &#34;&#34;&#34;
        players_alive=[]
        users_alive=[]
        for player in self.players:
            if player.is_alive():
                players_alive.append(player)
                users_alive.append(player.user)
        await self.channel_public_place.send(self.vivant.mention+&#34;,vous allez voter pour la mort d&#39;un membre du village!&#34;)
        await self.channel_polling.send(self.vivant.mention+&#34;,vous allez voter pour la mort d&#39;un membre du village!&#34;)
        message=&#34;&#34;
        for j in range(0,len(players_alive)):
            message=message+emoji[j]+users_alive[j].name+&#34;\n&#34;
        message_vote=await self.channel_polling.send(&#34;Votez pour les personnes qui doivent mourir, parmi:\n&#34;+message)
        for j in range(0,len(players_alive)):
            await message_vote.add_reaction(emoji[j])
        vote=[0 for z in range(0,len(players_alive))]
        await asyncio.sleep(60)
        cache_msg = await self.channel_polling.fetch_message(message_vote.id)
        i=-1
        for reactions in cache_msg.reactions:
            i=i+1
            user_list = [user async for user in reactions.users() if user != bot.user]
            for user in user_list:
                if user in users_alive and i &lt; len(players_alive):
                    vote[i]+=1
                    if self.with_mayor == True and user == self.mayor.user:
                        vote[i]+=1
        
        m=max(vote)
        im=[a for a, j in enumerate(vote) if j == m]
        if len(im) != 1:
            message=&#34;Egalité, c&#39;est le second round entre\n&#34;
            for j in range (0,len(im)):
                message=message+emoji[j]+users_alive[im[j]].name+&#34;\n&#34;
            message_vote=await self.channel_polling.send(message)
            for j in range (0,len(im)):
                await message_vote.add_reaction(emoji[j])
            vote=[0 for z in range(0,len(im))]
            await asyncio.sleep(60)
            i=-1
            for reactions in cache_msg.reactions:
                i=i+1
                user_list = [user async for user in reactions.users() if user != bot.user]
                for user in user_list:
                    if user in users_alive and i &lt; len(im):
                        vote[i]+=1
                        if self.with_mayor == True and user.id == self.mayor.user.id:
                            vote[i]+=1
            m=max(vote)
            print(&#34;vote = &#34;,vote)
            temp=[a for a, j in enumerate(vote) if j == m]
            im2=[]
            for t in temp:
                im2.append(im[t])
            im=im2
        if len(im) ==1:
            message=&#34;Vous avez décidé de pendre &#34;+users_alive[im[0]].name+&#34; !!&#34;
            await self.channel_polling.send(message)
            await self.channel_public_place.send(message)
            im=im[0]
            await players_alive[im].kill(self.channel_public_place,self.channel_graveyard,self.channel_recap,self.vivant,self.mort)
        else:
            message = &#34;Il y a encore égalité, personne ne va mourir.&#34;
            await self.channel_polling.send(message)
            await self.channel_public_place.send(message)

    async def nuit(self):
        &#34;&#34;&#34;starts the nigth
        &#34;&#34;&#34;
        self.night_death=[]
        await self.channel_public_place.send(&#34;C&#39;est la nuit, le village s&#39;endort! &#34;+self.vivant.mention)
        await self.channel_recap.send(&#34;Nuit &#34;+str(self.day)+&#34;:&#34;)
        self.day+=1
        for player in self.players:
            await player.nuit(self.channel_public_place)
        if self.lover!=None:
            await self.lover.nuit()
    
    async def jour(self):
        &#34;&#34;&#34;starts the day
        &#34;&#34;&#34;
        await self.channel_public_place.send(&#34;C&#39;est le jour, le village se reveille! &#34;+self.vivant.mention)
        await self.channel_recap.send(&#34;Jour &#34;+str(self.day)+&#34;:&#34;)
        for player in self.players:
            if player.is_alive():
                await player.role.jour(self.channel_public_place,player.user)
        if self.lover!=None:
            await self.lover.jour()
    
    async def loups(self,bot):
        &#34;&#34;&#34;starts the round of the wolf(s)

        Args:
            bot: _description_
        &#34;&#34;&#34;
        players=self.players
        loups=[]
        non_loups=[]
        for player in players:
            if player.is_alive():
                if player.role.name==&#34;Loup&#34;:
                    loups.append(player)
                else:
                    non_loups.append(player)
        if len(loups) != 0:
            smention=&#34;&#34;
            for loup in loups:
                smention=smention+loup.user.mention
            chan_loup=loups[0].role.channel
            message=&#34;&#34;
            i=0
            for non_loup in non_loups:
                message=message+ emoji[i] + non_loup.user.name+&#39;\n&#39;
                i=i+1

            if len(loups) == 1:
                message_loup=await chan_loup.send(smention+&#34; Salut le loup, tu dois choisir qui tu veux tuer cette nuit:\n&#34;+message)
            else:
                message_loup=await chan_loup.send(smention+&#34; Salut les loups, vous devez choisir qui vous voulez tuer cette nuit:\n&#34;+message)
            await message_loup.pin()
            for j in range(0,i):
                await message_loup.add_reaction(emoji[j])
            meurtre=[0 for z in range(0,len(non_loups))]
            await asyncio.sleep(60)
            def is_wolf(user):
                for w in loups:
                    if w.user==user:
                        return(True)
                return(False)
            cache_msg = await message_loup.channel.fetch_message(message_loup.id)
            i=-1
            for reactions in cache_msg.reactions:
                i=i+1
                user_list = [user async for user in reactions.users() if user != bot.user]
                
                for user in user_list:
                    if is_wolf(user) and i &lt; len(non_loups):
                        meurtre[i]+=1
            
            imax=[-1]
            vmax=0
            for z in range (0,len(non_loups)):
                if vmax == meurtre[z]:
                    imax.append(z)
                elif vmax &lt; meurtre[z]:
                    vmax=meurtre[z]
                    imax=[z]
            mes=&#34;&#34;
            mort_loup=None
            if imax[0]==-1:
                mes=&#34;Vous n&#39;avez choisi personne, le vote se fera aléatoirement\n&#34;
                rand=random.randint(0,len(non_loups)-1)
                mort_loup=non_loups[rand]
                mes=mes+&#34;C&#39;est donc &#34;+mort_loup.user.name+&#34; qui va mourir&#34;
            elif len(imax) != 1:
                mes=&#34;Il y a égalité, le vote se fera aléatoirement parmi les heureux élus\n&#34;
                rand=random.randint(0,len(imax)-1)
                mort_loup=non_loups[imax[rand]]
                mes=mes+&#34;C&#39;est donc &#34;+mort_loup.user.name+&#34; qui va mourir&#34;
            else:
                mort_loup=non_loups[imax[0]]
                mes=&#34;Vous avez décidé de tuer &#34;+mort_loup.user.name
            await chan_loup.send(mes)
            self.night_death.append(mort_loup)

    async def check_end(self):
        &#34;&#34;&#34;return true if the game is ended, false if not

        Returns:
            bool
        &#34;&#34;&#34;
        gentil=0
        mechant=0
        players_alive=[]
        for player in self.players:
            if player.is_alive():
                players_alive.append(player)
        for player in players_alive:
            if player.role.side == 1:
                gentil+=1
                if player==self.mayor:
                    gentil+=1
            else:
                mechant+=1
                if player==self.mayor:
                    mechant+=1
        print(&#34;gentil = &#34;,gentil, &#34;   méchant =&#34;, mechant)
        if gentil==0 and mechant == 0:
            await self.channel_public_place.send(&#34;La partie est fini ! c&#39;est une égalité ! GG à tous le monde&#34;)
            self.finish()
            return(True)
        elif gentil ==0:
            await self.channel_public_place.send(&#34;Les villageois ont perdu !! GG aux autre !!&#34;)
            self.finish()
            return True
        elif mechant ==0:
            await self.channel_public_place.send(&#34;Les villageois ont gagné !! GG à eux !!&#34;)
            self.finish()
            return True
        elif gentil==1 and mechant ==1 and len(players_alive)==2:
            if self.lover !=None and (self.lover.player1 == players_alive[0] or self.lover.player1 == players_alive[1]):
                await self.channel_public_place.send(&#34;Les amoureux ont gagné !! GG à eux !!&#34;)
                self.finish()
                return True
        return False</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="botclass.Chasseur"><code class="flex name class">
<span>class <span class="ident">Chasseur</span></span>
<span>(</span><span>channel)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents the Hunter 'Role'
Composed by :
name (String): the name of the 'Role'
channel (class discord.TextChannel): channel links to the player
side (int): 1 if the role is for the village, -1 if not, 0 if neutral</p>
<p>Initializes the Hunter.
He is with the Village</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code>class discord.TextChannel</code></dt>
<dd>channel links to the player</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Chasseur(Role):
    &#34;&#34;&#34;
    Represents the Hunter &#39;Role&#39;
    Composed by :
        name (String): the name of the &#39;Role&#39;
        channel (class discord.TextChannel): channel links to the player
        side (int): 1 if the role is for the village, -1 if not, 0 if neutral
    &#34;&#34;&#34;
    def __init__(self,channel):
        &#34;&#34;&#34;Initializes the Hunter.
        He is with the Village

        Args:
            channel (class discord.TextChannel): channel links to the player
        &#34;&#34;&#34;
        self.name=&#34;Chasseur&#34;
        self.channel=channel
        self.side=1
        self.power=True
    async def action(self,game,bot):
        &#34;&#34;&#34;start the turn of the Hunter.
        When he dies, he can kill someone else or do nothing
        Args:
            game (class Game): The current game party
            bot (class Bot): The current bot
            
        return: Nothing
        &#34;&#34;&#34;
        if self.power==True:
            self.power=False
            #je vais demander qui il veut tuer
            players=game.players
            chasseur=None
            targets=[]
            for player in players:
                if player.role.name!=self.name and player.is_alive():
                    targets.append(player)
                elif player.role.name==&#34;Chasseur&#34;:
                    chasseur = player
            message=&#34;Salut &#34;+chasseur.user.mention+&#34;,tu es mort, tu dois choisir qui va mourir ou ne rien faire:\n&#34;
            i=0
            for target in targets:
                message=message+ emoji[i] +&#34; &#34;+ target.user.name+&#39;\n&#39;
                i=i+1
            message_chasseur=await chasseur.role.channel.send(message)
            await message_chasseur.pin()
            for j in range(0,i):
                await message_chasseur.add_reaction(emoji[j])
            await message_chasseur.add_reaction(&#39;💤&#39;)
            await message_chasseur.add_reaction(&#39;✅&#39;)
            
            choice=[]
            def checkChasseur(reaction,user):
                if user == chasseur.user and reaction.message.id == message_chasseur.id and str(reaction.emoji) == &#39;✅&#39; :
                    return(True)
                return(False)
            try:
                await bot.wait_for(&#34;reaction_add&#34;, timeout=1*60, check=checkChasseur)
                cache_msg = await message_chasseur.channel.fetch_message(message_chasseur.id)
                i=-1
                for reactions in cache_msg.reactions:
                    i=i+1
                    user_list = [user async for user in reactions.users() if user != bot.user]
                    
                    for user in user_list:
                        if user.id ==chasseur.user.id and i &lt; len(targets)+1:
                            choice.append(i)
            except asyncio.TimeoutError:
                await chasseur.role.channel.send(&#34;Le temps est dépassé, le choix sera aléatoire&#34;)
                choice=[random.randint(0,len(targets))]
            if len(choice) !=1:
                choice=[random.randint(0,len(targets))]
                await chasseur.role.channel.send(&#34;C&#39;est impossible, le choix sera aléatoire&#34;)
            if choice[0] == len(targets):
                await chasseur.role.channel.send(&#34;Tu ne fais rien, tu es pacifiste.&#34;)
                return()
            mort=targets[choice[0]]
            #je tue
            await game.channel_public_place.send(&#34;Le chasseur a décidé de tirer sur &#34;+mort.user.mention)
            await game.channel_recap.send(&#34;Le chasseur a décidé de tirer sur &#34;+mort.user.mention)
            await mort.kill(game.channel_public_place,game.channel_graveyard,game.channel_recap,game.vivant,game.mort)
            await chasseur.role.channel.send(&#34;Tu as décidé de tuer &#34;+mort.user.name)
            #check cupidon
            await game.check_lover()
    async def jour(self,channel_public_place,user):
        &#34;&#34;&#34;set the role for the day
        The hunter can speak during the day in the public channel.

        Args:
            channel_public_place (class discord.TextChannel): the public channel of the current game
            user (class discord.User): The user concerned
        &#34;&#34;&#34;
        await channel_public_place.set_permissions(user,read_messages=True,send_messages=True)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="botclass.Role" href="#botclass.Role">Role</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="botclass.Chasseur.action"><code class="name flex">
<span>async def <span class="ident">action</span></span>(<span>self, game, bot)</span>
</code></dt>
<dd>
<div class="desc"><p>start the turn of the Hunter.
When he dies, he can kill someone else or do nothing</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>game</code></strong> :&ensp;<code>class <a title="botclass.Game" href="#botclass.Game">Game</a></code></dt>
<dd>The current game party</dd>
<dt><strong><code>bot</code></strong> :&ensp;<code>class Bot</code></dt>
<dd>The current bot</dd>
</dl>
<p>return: Nothing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def action(self,game,bot):
    &#34;&#34;&#34;start the turn of the Hunter.
    When he dies, he can kill someone else or do nothing
    Args:
        game (class Game): The current game party
        bot (class Bot): The current bot
        
    return: Nothing
    &#34;&#34;&#34;
    if self.power==True:
        self.power=False
        #je vais demander qui il veut tuer
        players=game.players
        chasseur=None
        targets=[]
        for player in players:
            if player.role.name!=self.name and player.is_alive():
                targets.append(player)
            elif player.role.name==&#34;Chasseur&#34;:
                chasseur = player
        message=&#34;Salut &#34;+chasseur.user.mention+&#34;,tu es mort, tu dois choisir qui va mourir ou ne rien faire:\n&#34;
        i=0
        for target in targets:
            message=message+ emoji[i] +&#34; &#34;+ target.user.name+&#39;\n&#39;
            i=i+1
        message_chasseur=await chasseur.role.channel.send(message)
        await message_chasseur.pin()
        for j in range(0,i):
            await message_chasseur.add_reaction(emoji[j])
        await message_chasseur.add_reaction(&#39;💤&#39;)
        await message_chasseur.add_reaction(&#39;✅&#39;)
        
        choice=[]
        def checkChasseur(reaction,user):
            if user == chasseur.user and reaction.message.id == message_chasseur.id and str(reaction.emoji) == &#39;✅&#39; :
                return(True)
            return(False)
        try:
            await bot.wait_for(&#34;reaction_add&#34;, timeout=1*60, check=checkChasseur)
            cache_msg = await message_chasseur.channel.fetch_message(message_chasseur.id)
            i=-1
            for reactions in cache_msg.reactions:
                i=i+1
                user_list = [user async for user in reactions.users() if user != bot.user]
                
                for user in user_list:
                    if user.id ==chasseur.user.id and i &lt; len(targets)+1:
                        choice.append(i)
        except asyncio.TimeoutError:
            await chasseur.role.channel.send(&#34;Le temps est dépassé, le choix sera aléatoire&#34;)
            choice=[random.randint(0,len(targets))]
        if len(choice) !=1:
            choice=[random.randint(0,len(targets))]
            await chasseur.role.channel.send(&#34;C&#39;est impossible, le choix sera aléatoire&#34;)
        if choice[0] == len(targets):
            await chasseur.role.channel.send(&#34;Tu ne fais rien, tu es pacifiste.&#34;)
            return()
        mort=targets[choice[0]]
        #je tue
        await game.channel_public_place.send(&#34;Le chasseur a décidé de tirer sur &#34;+mort.user.mention)
        await game.channel_recap.send(&#34;Le chasseur a décidé de tirer sur &#34;+mort.user.mention)
        await mort.kill(game.channel_public_place,game.channel_graveyard,game.channel_recap,game.vivant,game.mort)
        await chasseur.role.channel.send(&#34;Tu as décidé de tuer &#34;+mort.user.name)
        #check cupidon
        await game.check_lover()</code></pre>
</details>
</dd>
<dt id="botclass.Chasseur.jour"><code class="name flex">
<span>async def <span class="ident">jour</span></span>(<span>self, channel_public_place, user)</span>
</code></dt>
<dd>
<div class="desc"><p>set the role for the day
The hunter can speak during the day in the public channel.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>channel_public_place</code></strong> :&ensp;<code>class discord.TextChannel</code></dt>
<dd>the public channel of the current game</dd>
<dt><strong><code>user</code></strong> :&ensp;<code>class discord.User</code></dt>
<dd>The user concerned</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def jour(self,channel_public_place,user):
    &#34;&#34;&#34;set the role for the day
    The hunter can speak during the day in the public channel.

    Args:
        channel_public_place (class discord.TextChannel): the public channel of the current game
        user (class discord.User): The user concerned
    &#34;&#34;&#34;
    await channel_public_place.set_permissions(user,read_messages=True,send_messages=True)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="botclass.Cupidon"><code class="flex name class">
<span>class <span class="ident">Cupidon</span></span>
<span>(</span><span>channel)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents the Cupidon 'Role'
Composed by :
name (String): the name of the 'Role'
channel (class discord.TextChannel): channel links to the player
side (int): 1 if the role is for the village, -1 if not, 0 if neutral</p>
<p>Initializes Cupidon.
He is with the Village</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code>class discord.TextChannel</code></dt>
<dd>channel links to the player</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Cupidon(Role):
    &#34;&#34;&#34;
    Represents the Cupidon &#39;Role&#39;
    Composed by :
        name (String): the name of the &#39;Role&#39;
        channel (class discord.TextChannel): channel links to the player
        side (int): 1 if the role is for the village, -1 if not, 0 if neutral
    &#34;&#34;&#34;
    
    def __init__(self,channel):
        &#34;&#34;&#34;Initializes Cupidon.
        He is with the Village

        Args:
            channel (class discord.TextChannel): channel links to the player
        &#34;&#34;&#34;
        self.name=&#34;Cupidon&#34;
        self.channel=channel
        self.power=True
        self.side=1
    async def action(self,cupidon,game,bot):
        &#34;&#34;&#34;start the turn of Cupidon.
        He chooses a couple at the begining of the game
        Args:
            game (class Game): The current game party
            bot (class Bot): The current bot
            
        return: Nothing
        &#34;&#34;&#34;
        if self.power==True:
            self.power=False
            players=game.players
            #on demande à cupidon qui mettre en couple
            message=&#34;&#34;
            i=0
            for player in players:
                message=message+ emoji[i] + player.user.name+&#39;\n&#39;
                i=i+1
    
            message_cupidon=await self.channel.send(cupidon.user.mention+&#34;! Salut Cupidon, tu dois choisir qui va être amoureux parmi:\n&#34;+message)
            def checkCupidon(reaction,user):
                if user==cupidon.user and reaction.message.id == message_cupidon.id and (str(reaction.emoji) == &#39;✅&#39; or str(reaction.emoji) ==&#39;❌&#39;):
                    return(True)
                return(False)

            for j in range(0,i):
                await message_cupidon.add_reaction(emoji[j])
            await message_cupidon.add_reaction(&#39;✅&#39;)
            couple=[]
            try:
                await bot.wait_for(&#34;reaction_add&#34;, timeout=60, check=checkCupidon)
                cache_msg = await message_cupidon.channel.fetch_message(message_cupidon.id)
                i=-1
                for reactions in cache_msg.reactions:
                    i=i+1
                    user_list = [user async for user in reactions.users() if user != bot.user]
                    
                    for user in user_list:
                        if user==cupidon.user and i &lt; len(players):
                            couple.append(players[i])
            except asyncio.TimeoutError:
                await self.channel.send(&#34;Le temps est dépassé, le choix sera aléatoire&#34;)
                couple.append(players[random.randint(0,len(players)-1)])
                jalea=players[random.randint(0,len(players)-1)]
                while jalea.user == couple[0].user:
                    jalea=players[random.randint(0,len(players)-1)]
                couple.append(jalea)
            if len(couple) !=2:
                await self.channel.send(&#34;Erreur dans la saisie, le choix est aléatoire&#34;)
                couple.append(players[random.randint(0,len(players)-1)])
                jalea=players[random.randint(0,len(players)-1)]
                while jalea.user == couple[0].user:
                    jalea=players[random.randint(0,len(players)-1)]
                couple.append(jalea)
            mes=&#34;Le couple est composé de &#34;+couple[0].user.name + &#34; et &#34;+ couple[1].user.name
            await self.channel.send(mes)
            print(couple)
            channel_lover=await game.category.create_text_channel(&#34;Amoureux&#34;)
            game.def_lover(Lover(couple[1],couple[0],channel_lover))
            await channel_lover.set_permissions(couple[1].user,read_messages=True,send_messages=True)
            await channel_lover.set_permissions(couple[0].user,read_messages=True,send_messages=True)
            await channel_lover.send(&#34;Salut &#34;+couple[1].user.mention+&#34; et &#34;+couple[0].user.mention+&#34; askip vous êtes en couple ;) !&#34;)
    async def jour(self,channel_public_place,user):
        &#34;&#34;&#34;set the role for the day
        Cupidon can speak during the day in the public channel.

        Args:
            channel_public_place (class discord.TextChannel): the public channel of the current game
            user (class discord.User): The user concerned
        &#34;&#34;&#34;
        await channel_public_place.set_permissions(user,read_messages=True,send_messages=True)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="botclass.Role" href="#botclass.Role">Role</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="botclass.Cupidon.action"><code class="name flex">
<span>async def <span class="ident">action</span></span>(<span>self, cupidon, game, bot)</span>
</code></dt>
<dd>
<div class="desc"><p>start the turn of Cupidon.
He chooses a couple at the begining of the game</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>game</code></strong> :&ensp;<code>class <a title="botclass.Game" href="#botclass.Game">Game</a></code></dt>
<dd>The current game party</dd>
<dt><strong><code>bot</code></strong> :&ensp;<code>class Bot</code></dt>
<dd>The current bot</dd>
</dl>
<p>return: Nothing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def action(self,cupidon,game,bot):
    &#34;&#34;&#34;start the turn of Cupidon.
    He chooses a couple at the begining of the game
    Args:
        game (class Game): The current game party
        bot (class Bot): The current bot
        
    return: Nothing
    &#34;&#34;&#34;
    if self.power==True:
        self.power=False
        players=game.players
        #on demande à cupidon qui mettre en couple
        message=&#34;&#34;
        i=0
        for player in players:
            message=message+ emoji[i] + player.user.name+&#39;\n&#39;
            i=i+1

        message_cupidon=await self.channel.send(cupidon.user.mention+&#34;! Salut Cupidon, tu dois choisir qui va être amoureux parmi:\n&#34;+message)
        def checkCupidon(reaction,user):
            if user==cupidon.user and reaction.message.id == message_cupidon.id and (str(reaction.emoji) == &#39;✅&#39; or str(reaction.emoji) ==&#39;❌&#39;):
                return(True)
            return(False)

        for j in range(0,i):
            await message_cupidon.add_reaction(emoji[j])
        await message_cupidon.add_reaction(&#39;✅&#39;)
        couple=[]
        try:
            await bot.wait_for(&#34;reaction_add&#34;, timeout=60, check=checkCupidon)
            cache_msg = await message_cupidon.channel.fetch_message(message_cupidon.id)
            i=-1
            for reactions in cache_msg.reactions:
                i=i+1
                user_list = [user async for user in reactions.users() if user != bot.user]
                
                for user in user_list:
                    if user==cupidon.user and i &lt; len(players):
                        couple.append(players[i])
        except asyncio.TimeoutError:
            await self.channel.send(&#34;Le temps est dépassé, le choix sera aléatoire&#34;)
            couple.append(players[random.randint(0,len(players)-1)])
            jalea=players[random.randint(0,len(players)-1)]
            while jalea.user == couple[0].user:
                jalea=players[random.randint(0,len(players)-1)]
            couple.append(jalea)
        if len(couple) !=2:
            await self.channel.send(&#34;Erreur dans la saisie, le choix est aléatoire&#34;)
            couple.append(players[random.randint(0,len(players)-1)])
            jalea=players[random.randint(0,len(players)-1)]
            while jalea.user == couple[0].user:
                jalea=players[random.randint(0,len(players)-1)]
            couple.append(jalea)
        mes=&#34;Le couple est composé de &#34;+couple[0].user.name + &#34; et &#34;+ couple[1].user.name
        await self.channel.send(mes)
        print(couple)
        channel_lover=await game.category.create_text_channel(&#34;Amoureux&#34;)
        game.def_lover(Lover(couple[1],couple[0],channel_lover))
        await channel_lover.set_permissions(couple[1].user,read_messages=True,send_messages=True)
        await channel_lover.set_permissions(couple[0].user,read_messages=True,send_messages=True)
        await channel_lover.send(&#34;Salut &#34;+couple[1].user.mention+&#34; et &#34;+couple[0].user.mention+&#34; askip vous êtes en couple ;) !&#34;)</code></pre>
</details>
</dd>
<dt id="botclass.Cupidon.jour"><code class="name flex">
<span>async def <span class="ident">jour</span></span>(<span>self, channel_public_place, user)</span>
</code></dt>
<dd>
<div class="desc"><p>set the role for the day
Cupidon can speak during the day in the public channel.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>channel_public_place</code></strong> :&ensp;<code>class discord.TextChannel</code></dt>
<dd>the public channel of the current game</dd>
<dt><strong><code>user</code></strong> :&ensp;<code>class discord.User</code></dt>
<dd>The user concerned</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def jour(self,channel_public_place,user):
    &#34;&#34;&#34;set the role for the day
    Cupidon can speak during the day in the public channel.

    Args:
        channel_public_place (class discord.TextChannel): the public channel of the current game
        user (class discord.User): The user concerned
    &#34;&#34;&#34;
    await channel_public_place.set_permissions(user,read_messages=True,send_messages=True)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="botclass.Game"><code class="flex name class">
<span>class <span class="ident">Game</span></span>
</code></dt>
<dd>
<div class="desc"><p>represents a Game</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Game:
    &#34;&#34;&#34;represents a Game
    &#34;&#34;&#34;
    def __init__(self):
        self.started=False
        self.category=None
        self.channel_public_place=None
        self.channel_graveyard=None
        self.channel_polling=None
        self.players=None
        self.night_death=[]
        self.lover=None
        self.with_mayor=True
        self.mayor=None
        self.day=0

    def initialize(self,category,public_place,graveyard,polling,recap,players,vivant,mort):
        &#34;&#34;&#34;set all the parameters (specific to the discord&#39;s server)
        
        needs :
            category: class discord.CategoryChannel
            public_place: class discord.TextChannel
            graveyard: class discord.TextChannel
            polling: class discord.TextChannel
            recap: class discord.TextChannel
            players: list of players
            vivant: class discord.Role
            mort: class discord.Role
        &#34;&#34;&#34;
        self.category=category
        self.channel_public_place=public_place
        self.channel_graveyard=graveyard
        self.channel_polling=polling
        self.channel_recap=recap
        self.players=players
        self.vivant=vivant
        self.mort=mort
    
    def is_started(self):
        &#34;&#34;&#34;returns &#39;true&#39; if the game is already started / &#39;false&#39; if not
        &#34;&#34;&#34;
        return(self.started)
    def start(self):
        &#34;&#34;&#34;set started paramaters to true (the game is started)
        &#34;&#34;&#34;
        self.started=True
    def finish(self):
        &#34;&#34;&#34;uses at the end of the game
        &#34;&#34;&#34;
        print(&#34;PARTIE FINI&#34;)
        self.started=False
        self.channel_public_place=None
        self.channel_graveyard=None
        self.channel_polling=None
        self.players=None
        self.night_death=[]
        self.lover=None
        self.with_mayor=True
        self.mayor=None
    def def_lover(self,lover):
        &#34;&#34;&#34;set the couple
        &#34;&#34;&#34;
        self.lover=lover
    async def check_lover(self):
        &#34;&#34;&#34;checks if one member of the couple is dead or not
        &#34;&#34;&#34;
        if self.lover!=None:
            await self.lover.check_death(self.channel_public_place,self.channel_graveyard,self.channel_recap,self.vivant,self.mort)
    
    def without_mayor(self):
        self.with_mayor=False

    async def define_mayor(self,bot):
        &#34;&#34;&#34;does the election of the mayor

        Args:
            bot:  class discord.ClientUser
        &#34;&#34;&#34;
        if self.mayor == None and self.with_mayor==True:
            players_alive=[]
            users_alive=[]
            
            for player in self.players:
                if player.is_alive():
                    players_alive.append(player)
                    users_alive.append(player.user)
            await self.channel_public_place.send(&#34;Le vote pour le maire va commencer !!&#34;)
            message=&#34;&#34;
            i=0
            
            for player in players_alive:
                message=message+ emoji[i] + player.user.name+&#39;\n&#39;
                i=i+1
            message_place_publique=await self.channel_polling.send(&#34;la personne qui aura le plus grand nombre de vote sera maire, parmi:\n&#34;+message)
            for j in range(0,i):
                await message_place_publique.add_reaction(emoji[j])
            election=[0 for z in range(0,len(players_alive))]
            await asyncio.sleep(60)
            cache_msg = await self.channel_polling.fetch_message(message_place_publique.id)
            i=-1
            for reactions in cache_msg.reactions:
                i=i+1
                user_list = [user async for user in reactions.users() if user != bot.user]
                for user in user_list:
                    if user in users_alive and i &lt; len(users_alive):
                        election[i]+=1
            imax=[-1]
            vmax=0
            print(election)
            for z in range (0,len(players_alive)):
                if vmax == election[z]:
                    imax.append(z)
                elif vmax &lt; election[z]:
                    vmax=election[z]
                    imax=[z]
            mes=&#34;&#34;
            if imax[0]==-1:
                mes=&#34;Vous n&#39;avez choisi personne, le vote se fera aléatoirement\n&#34;
                rand=random.randint(0,len(players_alive)-1)
                maire=players_alive[rand]
                mes=mes+&#34;C&#39;est donc &#34;+maire.user.mention+&#34; qui sera maire&#34;
            elif len(imax) != 1:
                mes=&#34;Il y a égalité, le vote se fera aléatoirement parmi les heureux élus\n&#34;
                rand=random.randint(0,len(imax)-1)
                maire=players_alive[rand]
                mes=mes+&#34;C&#39;est donc &#34;+maire.user.mention+&#34; qui sera maire&#34;
            else:
                maire=players_alive[imax[0]]
                mes=&#34;Vous avez décidé d&#39;élire &#34;+maire.user.mention
            await self.channel_public_place.send(mes)
            await self.channel_polling.send(mes)
            await self.channel_recap.send(mes)
            self.mayor=maire

    async def check_mayor(self,bot):
        &#34;&#34;&#34;checks if the mayor is dead or not.
        If the mayor is dead, he will choose the next mayor. If he doesn&#39;t choose, the choice is random.

        Args:
            bot: class discord.ClientUser
        &#34;&#34;&#34;
        if self.mayor!= None and self.with_mayor==True:
            if self.mayor.is_alive()==False:
                players_alive=[]
                users_alive=[]
                for player in self.players:
                    if player.is_alive():
                        players_alive.append(player)
                        users_alive.append(player.user)
                await self.channel_public_place.send(&#34;Le maire est mort, un nouveau maire doit être choisi!&#34;)
                message=&#34;&#34;
                for j in range(0,len(players_alive)):
                    message=message+emoji[j]+users_alive[j].name+&#34;\n&#34;
                message_perso=await self.channel_polling.send(self.mayor.user.mention+&#34; choisis qui sera maire à ta place, parmi:\n&#34;+message)
                for j in range(0,len(players_alive)):
                    await message_perso.add_reaction(emoji[j])
                await message_perso.add_reaction(&#39;✅&#39;)
                fmaire=[]
                def checkMaire(reaction,user):
                    if reaction.message.id == message_perso.id and (str(reaction.emoji) == &#39;✅&#39;) and user.id==self.mayor.user.id:
                        return(True)
                    return(False)
                try:
                    await bot.wait_for(&#34;reaction_add&#34;, timeout=60, check=checkMaire)
                    cache_msg = await self.channel_polling.fetch_message(message_perso.id)
                    i=-1
                    for reactions in cache_msg.reactions:
                        i=i+1
                        user_list = [user async for user in reactions.users() if user != bot.user]
                        for user in user_list:
                            if user == self.mayor.user and i&lt;len(players_alive):
                                fmaire.append(players_alive[i])
                except asyncio.TimeoutError:
                    await message_perso.channel.send(&#34;Le temps est dépassé, le choix sera aléatoire&#34;)
                    fmaire=[players_alive[random.randint(0,len(players_alive)-1)]]
                if len(fmaire) !=1:
                    await message_perso.channel.send(&#34;Erreur dans la saisie, le choix est aléatoire&#34;)
                    fmaire=[players_alive[random.randint(0,len(players_alive)-1)]]
                maire=fmaire[0]
                mes=&#34;Le nouveau maire est &#34;+maire.user.mention
                await self.channel_polling.send(mes)
                await self.channel_public_place.send(mes)
                self.mayor=maire

    async def vote(self,bot):
        &#34;&#34;&#34;does the vote to select the player which will die.
        
        Args:
            bot: class discord.ClientUser
        &#34;&#34;&#34;
        players_alive=[]
        users_alive=[]
        for player in self.players:
            if player.is_alive():
                players_alive.append(player)
                users_alive.append(player.user)
        await self.channel_public_place.send(self.vivant.mention+&#34;,vous allez voter pour la mort d&#39;un membre du village!&#34;)
        await self.channel_polling.send(self.vivant.mention+&#34;,vous allez voter pour la mort d&#39;un membre du village!&#34;)
        message=&#34;&#34;
        for j in range(0,len(players_alive)):
            message=message+emoji[j]+users_alive[j].name+&#34;\n&#34;
        message_vote=await self.channel_polling.send(&#34;Votez pour les personnes qui doivent mourir, parmi:\n&#34;+message)
        for j in range(0,len(players_alive)):
            await message_vote.add_reaction(emoji[j])
        vote=[0 for z in range(0,len(players_alive))]
        await asyncio.sleep(60)
        cache_msg = await self.channel_polling.fetch_message(message_vote.id)
        i=-1
        for reactions in cache_msg.reactions:
            i=i+1
            user_list = [user async for user in reactions.users() if user != bot.user]
            for user in user_list:
                if user in users_alive and i &lt; len(players_alive):
                    vote[i]+=1
                    if self.with_mayor == True and user == self.mayor.user:
                        vote[i]+=1
        
        m=max(vote)
        im=[a for a, j in enumerate(vote) if j == m]
        if len(im) != 1:
            message=&#34;Egalité, c&#39;est le second round entre\n&#34;
            for j in range (0,len(im)):
                message=message+emoji[j]+users_alive[im[j]].name+&#34;\n&#34;
            message_vote=await self.channel_polling.send(message)
            for j in range (0,len(im)):
                await message_vote.add_reaction(emoji[j])
            vote=[0 for z in range(0,len(im))]
            await asyncio.sleep(60)
            i=-1
            for reactions in cache_msg.reactions:
                i=i+1
                user_list = [user async for user in reactions.users() if user != bot.user]
                for user in user_list:
                    if user in users_alive and i &lt; len(im):
                        vote[i]+=1
                        if self.with_mayor == True and user.id == self.mayor.user.id:
                            vote[i]+=1
            m=max(vote)
            print(&#34;vote = &#34;,vote)
            temp=[a for a, j in enumerate(vote) if j == m]
            im2=[]
            for t in temp:
                im2.append(im[t])
            im=im2
        if len(im) ==1:
            message=&#34;Vous avez décidé de pendre &#34;+users_alive[im[0]].name+&#34; !!&#34;
            await self.channel_polling.send(message)
            await self.channel_public_place.send(message)
            im=im[0]
            await players_alive[im].kill(self.channel_public_place,self.channel_graveyard,self.channel_recap,self.vivant,self.mort)
        else:
            message = &#34;Il y a encore égalité, personne ne va mourir.&#34;
            await self.channel_polling.send(message)
            await self.channel_public_place.send(message)

    async def nuit(self):
        &#34;&#34;&#34;starts the nigth
        &#34;&#34;&#34;
        self.night_death=[]
        await self.channel_public_place.send(&#34;C&#39;est la nuit, le village s&#39;endort! &#34;+self.vivant.mention)
        await self.channel_recap.send(&#34;Nuit &#34;+str(self.day)+&#34;:&#34;)
        self.day+=1
        for player in self.players:
            await player.nuit(self.channel_public_place)
        if self.lover!=None:
            await self.lover.nuit()
    
    async def jour(self):
        &#34;&#34;&#34;starts the day
        &#34;&#34;&#34;
        await self.channel_public_place.send(&#34;C&#39;est le jour, le village se reveille! &#34;+self.vivant.mention)
        await self.channel_recap.send(&#34;Jour &#34;+str(self.day)+&#34;:&#34;)
        for player in self.players:
            if player.is_alive():
                await player.role.jour(self.channel_public_place,player.user)
        if self.lover!=None:
            await self.lover.jour()
    
    async def loups(self,bot):
        &#34;&#34;&#34;starts the round of the wolf(s)

        Args:
            bot: _description_
        &#34;&#34;&#34;
        players=self.players
        loups=[]
        non_loups=[]
        for player in players:
            if player.is_alive():
                if player.role.name==&#34;Loup&#34;:
                    loups.append(player)
                else:
                    non_loups.append(player)
        if len(loups) != 0:
            smention=&#34;&#34;
            for loup in loups:
                smention=smention+loup.user.mention
            chan_loup=loups[0].role.channel
            message=&#34;&#34;
            i=0
            for non_loup in non_loups:
                message=message+ emoji[i] + non_loup.user.name+&#39;\n&#39;
                i=i+1

            if len(loups) == 1:
                message_loup=await chan_loup.send(smention+&#34; Salut le loup, tu dois choisir qui tu veux tuer cette nuit:\n&#34;+message)
            else:
                message_loup=await chan_loup.send(smention+&#34; Salut les loups, vous devez choisir qui vous voulez tuer cette nuit:\n&#34;+message)
            await message_loup.pin()
            for j in range(0,i):
                await message_loup.add_reaction(emoji[j])
            meurtre=[0 for z in range(0,len(non_loups))]
            await asyncio.sleep(60)
            def is_wolf(user):
                for w in loups:
                    if w.user==user:
                        return(True)
                return(False)
            cache_msg = await message_loup.channel.fetch_message(message_loup.id)
            i=-1
            for reactions in cache_msg.reactions:
                i=i+1
                user_list = [user async for user in reactions.users() if user != bot.user]
                
                for user in user_list:
                    if is_wolf(user) and i &lt; len(non_loups):
                        meurtre[i]+=1
            
            imax=[-1]
            vmax=0
            for z in range (0,len(non_loups)):
                if vmax == meurtre[z]:
                    imax.append(z)
                elif vmax &lt; meurtre[z]:
                    vmax=meurtre[z]
                    imax=[z]
            mes=&#34;&#34;
            mort_loup=None
            if imax[0]==-1:
                mes=&#34;Vous n&#39;avez choisi personne, le vote se fera aléatoirement\n&#34;
                rand=random.randint(0,len(non_loups)-1)
                mort_loup=non_loups[rand]
                mes=mes+&#34;C&#39;est donc &#34;+mort_loup.user.name+&#34; qui va mourir&#34;
            elif len(imax) != 1:
                mes=&#34;Il y a égalité, le vote se fera aléatoirement parmi les heureux élus\n&#34;
                rand=random.randint(0,len(imax)-1)
                mort_loup=non_loups[imax[rand]]
                mes=mes+&#34;C&#39;est donc &#34;+mort_loup.user.name+&#34; qui va mourir&#34;
            else:
                mort_loup=non_loups[imax[0]]
                mes=&#34;Vous avez décidé de tuer &#34;+mort_loup.user.name
            await chan_loup.send(mes)
            self.night_death.append(mort_loup)

    async def check_end(self):
        &#34;&#34;&#34;return true if the game is ended, false if not

        Returns:
            bool
        &#34;&#34;&#34;
        gentil=0
        mechant=0
        players_alive=[]
        for player in self.players:
            if player.is_alive():
                players_alive.append(player)
        for player in players_alive:
            if player.role.side == 1:
                gentil+=1
                if player==self.mayor:
                    gentil+=1
            else:
                mechant+=1
                if player==self.mayor:
                    mechant+=1
        print(&#34;gentil = &#34;,gentil, &#34;   méchant =&#34;, mechant)
        if gentil==0 and mechant == 0:
            await self.channel_public_place.send(&#34;La partie est fini ! c&#39;est une égalité ! GG à tous le monde&#34;)
            self.finish()
            return(True)
        elif gentil ==0:
            await self.channel_public_place.send(&#34;Les villageois ont perdu !! GG aux autre !!&#34;)
            self.finish()
            return True
        elif mechant ==0:
            await self.channel_public_place.send(&#34;Les villageois ont gagné !! GG à eux !!&#34;)
            self.finish()
            return True
        elif gentil==1 and mechant ==1 and len(players_alive)==2:
            if self.lover !=None and (self.lover.player1 == players_alive[0] or self.lover.player1 == players_alive[1]):
                await self.channel_public_place.send(&#34;Les amoureux ont gagné !! GG à eux !!&#34;)
                self.finish()
                return True
        return False</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="botclass.Game.check_end"><code class="name flex">
<span>async def <span class="ident">check_end</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return true if the game is ended, false if not</p>
<h2 id="returns">Returns</h2>
<p>bool</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def check_end(self):
    &#34;&#34;&#34;return true if the game is ended, false if not

    Returns:
        bool
    &#34;&#34;&#34;
    gentil=0
    mechant=0
    players_alive=[]
    for player in self.players:
        if player.is_alive():
            players_alive.append(player)
    for player in players_alive:
        if player.role.side == 1:
            gentil+=1
            if player==self.mayor:
                gentil+=1
        else:
            mechant+=1
            if player==self.mayor:
                mechant+=1
    print(&#34;gentil = &#34;,gentil, &#34;   méchant =&#34;, mechant)
    if gentil==0 and mechant == 0:
        await self.channel_public_place.send(&#34;La partie est fini ! c&#39;est une égalité ! GG à tous le monde&#34;)
        self.finish()
        return(True)
    elif gentil ==0:
        await self.channel_public_place.send(&#34;Les villageois ont perdu !! GG aux autre !!&#34;)
        self.finish()
        return True
    elif mechant ==0:
        await self.channel_public_place.send(&#34;Les villageois ont gagné !! GG à eux !!&#34;)
        self.finish()
        return True
    elif gentil==1 and mechant ==1 and len(players_alive)==2:
        if self.lover !=None and (self.lover.player1 == players_alive[0] or self.lover.player1 == players_alive[1]):
            await self.channel_public_place.send(&#34;Les amoureux ont gagné !! GG à eux !!&#34;)
            self.finish()
            return True
    return False</code></pre>
</details>
</dd>
<dt id="botclass.Game.check_lover"><code class="name flex">
<span>async def <span class="ident">check_lover</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>checks if one member of the couple is dead or not</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def check_lover(self):
    &#34;&#34;&#34;checks if one member of the couple is dead or not
    &#34;&#34;&#34;
    if self.lover!=None:
        await self.lover.check_death(self.channel_public_place,self.channel_graveyard,self.channel_recap,self.vivant,self.mort)</code></pre>
</details>
</dd>
<dt id="botclass.Game.check_mayor"><code class="name flex">
<span>async def <span class="ident">check_mayor</span></span>(<span>self, bot)</span>
</code></dt>
<dd>
<div class="desc"><p>checks if the mayor is dead or not.
If the mayor is dead, he will choose the next mayor. If he doesn't choose, the choice is random.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bot</code></strong></dt>
<dd>class discord.ClientUser</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def check_mayor(self,bot):
    &#34;&#34;&#34;checks if the mayor is dead or not.
    If the mayor is dead, he will choose the next mayor. If he doesn&#39;t choose, the choice is random.

    Args:
        bot: class discord.ClientUser
    &#34;&#34;&#34;
    if self.mayor!= None and self.with_mayor==True:
        if self.mayor.is_alive()==False:
            players_alive=[]
            users_alive=[]
            for player in self.players:
                if player.is_alive():
                    players_alive.append(player)
                    users_alive.append(player.user)
            await self.channel_public_place.send(&#34;Le maire est mort, un nouveau maire doit être choisi!&#34;)
            message=&#34;&#34;
            for j in range(0,len(players_alive)):
                message=message+emoji[j]+users_alive[j].name+&#34;\n&#34;
            message_perso=await self.channel_polling.send(self.mayor.user.mention+&#34; choisis qui sera maire à ta place, parmi:\n&#34;+message)
            for j in range(0,len(players_alive)):
                await message_perso.add_reaction(emoji[j])
            await message_perso.add_reaction(&#39;✅&#39;)
            fmaire=[]
            def checkMaire(reaction,user):
                if reaction.message.id == message_perso.id and (str(reaction.emoji) == &#39;✅&#39;) and user.id==self.mayor.user.id:
                    return(True)
                return(False)
            try:
                await bot.wait_for(&#34;reaction_add&#34;, timeout=60, check=checkMaire)
                cache_msg = await self.channel_polling.fetch_message(message_perso.id)
                i=-1
                for reactions in cache_msg.reactions:
                    i=i+1
                    user_list = [user async for user in reactions.users() if user != bot.user]
                    for user in user_list:
                        if user == self.mayor.user and i&lt;len(players_alive):
                            fmaire.append(players_alive[i])
            except asyncio.TimeoutError:
                await message_perso.channel.send(&#34;Le temps est dépassé, le choix sera aléatoire&#34;)
                fmaire=[players_alive[random.randint(0,len(players_alive)-1)]]
            if len(fmaire) !=1:
                await message_perso.channel.send(&#34;Erreur dans la saisie, le choix est aléatoire&#34;)
                fmaire=[players_alive[random.randint(0,len(players_alive)-1)]]
            maire=fmaire[0]
            mes=&#34;Le nouveau maire est &#34;+maire.user.mention
            await self.channel_polling.send(mes)
            await self.channel_public_place.send(mes)
            self.mayor=maire</code></pre>
</details>
</dd>
<dt id="botclass.Game.def_lover"><code class="name flex">
<span>def <span class="ident">def_lover</span></span>(<span>self, lover)</span>
</code></dt>
<dd>
<div class="desc"><p>set the couple</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def def_lover(self,lover):
    &#34;&#34;&#34;set the couple
    &#34;&#34;&#34;
    self.lover=lover</code></pre>
</details>
</dd>
<dt id="botclass.Game.define_mayor"><code class="name flex">
<span>async def <span class="ident">define_mayor</span></span>(<span>self, bot)</span>
</code></dt>
<dd>
<div class="desc"><p>does the election of the mayor</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bot</code></strong></dt>
<dd>class discord.ClientUser</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def define_mayor(self,bot):
    &#34;&#34;&#34;does the election of the mayor

    Args:
        bot:  class discord.ClientUser
    &#34;&#34;&#34;
    if self.mayor == None and self.with_mayor==True:
        players_alive=[]
        users_alive=[]
        
        for player in self.players:
            if player.is_alive():
                players_alive.append(player)
                users_alive.append(player.user)
        await self.channel_public_place.send(&#34;Le vote pour le maire va commencer !!&#34;)
        message=&#34;&#34;
        i=0
        
        for player in players_alive:
            message=message+ emoji[i] + player.user.name+&#39;\n&#39;
            i=i+1
        message_place_publique=await self.channel_polling.send(&#34;la personne qui aura le plus grand nombre de vote sera maire, parmi:\n&#34;+message)
        for j in range(0,i):
            await message_place_publique.add_reaction(emoji[j])
        election=[0 for z in range(0,len(players_alive))]
        await asyncio.sleep(60)
        cache_msg = await self.channel_polling.fetch_message(message_place_publique.id)
        i=-1
        for reactions in cache_msg.reactions:
            i=i+1
            user_list = [user async for user in reactions.users() if user != bot.user]
            for user in user_list:
                if user in users_alive and i &lt; len(users_alive):
                    election[i]+=1
        imax=[-1]
        vmax=0
        print(election)
        for z in range (0,len(players_alive)):
            if vmax == election[z]:
                imax.append(z)
            elif vmax &lt; election[z]:
                vmax=election[z]
                imax=[z]
        mes=&#34;&#34;
        if imax[0]==-1:
            mes=&#34;Vous n&#39;avez choisi personne, le vote se fera aléatoirement\n&#34;
            rand=random.randint(0,len(players_alive)-1)
            maire=players_alive[rand]
            mes=mes+&#34;C&#39;est donc &#34;+maire.user.mention+&#34; qui sera maire&#34;
        elif len(imax) != 1:
            mes=&#34;Il y a égalité, le vote se fera aléatoirement parmi les heureux élus\n&#34;
            rand=random.randint(0,len(imax)-1)
            maire=players_alive[rand]
            mes=mes+&#34;C&#39;est donc &#34;+maire.user.mention+&#34; qui sera maire&#34;
        else:
            maire=players_alive[imax[0]]
            mes=&#34;Vous avez décidé d&#39;élire &#34;+maire.user.mention
        await self.channel_public_place.send(mes)
        await self.channel_polling.send(mes)
        await self.channel_recap.send(mes)
        self.mayor=maire</code></pre>
</details>
</dd>
<dt id="botclass.Game.finish"><code class="name flex">
<span>def <span class="ident">finish</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>uses at the end of the game</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def finish(self):
    &#34;&#34;&#34;uses at the end of the game
    &#34;&#34;&#34;
    print(&#34;PARTIE FINI&#34;)
    self.started=False
    self.channel_public_place=None
    self.channel_graveyard=None
    self.channel_polling=None
    self.players=None
    self.night_death=[]
    self.lover=None
    self.with_mayor=True
    self.mayor=None</code></pre>
</details>
</dd>
<dt id="botclass.Game.initialize"><code class="name flex">
<span>def <span class="ident">initialize</span></span>(<span>self, category, public_place, graveyard, polling, recap, players, vivant, mort)</span>
</code></dt>
<dd>
<div class="desc"><p>set all the parameters (specific to the discord's server)</p>
<p>needs :
category: class discord.CategoryChannel
public_place: class discord.TextChannel
graveyard: class discord.TextChannel
polling: class discord.TextChannel
recap: class discord.TextChannel
players: list of players
vivant: class discord.Role
mort: class discord.Role</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize(self,category,public_place,graveyard,polling,recap,players,vivant,mort):
    &#34;&#34;&#34;set all the parameters (specific to the discord&#39;s server)
    
    needs :
        category: class discord.CategoryChannel
        public_place: class discord.TextChannel
        graveyard: class discord.TextChannel
        polling: class discord.TextChannel
        recap: class discord.TextChannel
        players: list of players
        vivant: class discord.Role
        mort: class discord.Role
    &#34;&#34;&#34;
    self.category=category
    self.channel_public_place=public_place
    self.channel_graveyard=graveyard
    self.channel_polling=polling
    self.channel_recap=recap
    self.players=players
    self.vivant=vivant
    self.mort=mort</code></pre>
</details>
</dd>
<dt id="botclass.Game.is_started"><code class="name flex">
<span>def <span class="ident">is_started</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>returns 'true' if the game is already started / 'false' if not</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_started(self):
    &#34;&#34;&#34;returns &#39;true&#39; if the game is already started / &#39;false&#39; if not
    &#34;&#34;&#34;
    return(self.started)</code></pre>
</details>
</dd>
<dt id="botclass.Game.jour"><code class="name flex">
<span>async def <span class="ident">jour</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>starts the day</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def jour(self):
    &#34;&#34;&#34;starts the day
    &#34;&#34;&#34;
    await self.channel_public_place.send(&#34;C&#39;est le jour, le village se reveille! &#34;+self.vivant.mention)
    await self.channel_recap.send(&#34;Jour &#34;+str(self.day)+&#34;:&#34;)
    for player in self.players:
        if player.is_alive():
            await player.role.jour(self.channel_public_place,player.user)
    if self.lover!=None:
        await self.lover.jour()</code></pre>
</details>
</dd>
<dt id="botclass.Game.loups"><code class="name flex">
<span>async def <span class="ident">loups</span></span>(<span>self, bot)</span>
</code></dt>
<dd>
<div class="desc"><p>starts the round of the wolf(s)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bot</code></strong></dt>
<dd><em>description</em></dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def loups(self,bot):
    &#34;&#34;&#34;starts the round of the wolf(s)

    Args:
        bot: _description_
    &#34;&#34;&#34;
    players=self.players
    loups=[]
    non_loups=[]
    for player in players:
        if player.is_alive():
            if player.role.name==&#34;Loup&#34;:
                loups.append(player)
            else:
                non_loups.append(player)
    if len(loups) != 0:
        smention=&#34;&#34;
        for loup in loups:
            smention=smention+loup.user.mention
        chan_loup=loups[0].role.channel
        message=&#34;&#34;
        i=0
        for non_loup in non_loups:
            message=message+ emoji[i] + non_loup.user.name+&#39;\n&#39;
            i=i+1

        if len(loups) == 1:
            message_loup=await chan_loup.send(smention+&#34; Salut le loup, tu dois choisir qui tu veux tuer cette nuit:\n&#34;+message)
        else:
            message_loup=await chan_loup.send(smention+&#34; Salut les loups, vous devez choisir qui vous voulez tuer cette nuit:\n&#34;+message)
        await message_loup.pin()
        for j in range(0,i):
            await message_loup.add_reaction(emoji[j])
        meurtre=[0 for z in range(0,len(non_loups))]
        await asyncio.sleep(60)
        def is_wolf(user):
            for w in loups:
                if w.user==user:
                    return(True)
            return(False)
        cache_msg = await message_loup.channel.fetch_message(message_loup.id)
        i=-1
        for reactions in cache_msg.reactions:
            i=i+1
            user_list = [user async for user in reactions.users() if user != bot.user]
            
            for user in user_list:
                if is_wolf(user) and i &lt; len(non_loups):
                    meurtre[i]+=1
        
        imax=[-1]
        vmax=0
        for z in range (0,len(non_loups)):
            if vmax == meurtre[z]:
                imax.append(z)
            elif vmax &lt; meurtre[z]:
                vmax=meurtre[z]
                imax=[z]
        mes=&#34;&#34;
        mort_loup=None
        if imax[0]==-1:
            mes=&#34;Vous n&#39;avez choisi personne, le vote se fera aléatoirement\n&#34;
            rand=random.randint(0,len(non_loups)-1)
            mort_loup=non_loups[rand]
            mes=mes+&#34;C&#39;est donc &#34;+mort_loup.user.name+&#34; qui va mourir&#34;
        elif len(imax) != 1:
            mes=&#34;Il y a égalité, le vote se fera aléatoirement parmi les heureux élus\n&#34;
            rand=random.randint(0,len(imax)-1)
            mort_loup=non_loups[imax[rand]]
            mes=mes+&#34;C&#39;est donc &#34;+mort_loup.user.name+&#34; qui va mourir&#34;
        else:
            mort_loup=non_loups[imax[0]]
            mes=&#34;Vous avez décidé de tuer &#34;+mort_loup.user.name
        await chan_loup.send(mes)
        self.night_death.append(mort_loup)</code></pre>
</details>
</dd>
<dt id="botclass.Game.nuit"><code class="name flex">
<span>async def <span class="ident">nuit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>starts the nigth</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def nuit(self):
    &#34;&#34;&#34;starts the nigth
    &#34;&#34;&#34;
    self.night_death=[]
    await self.channel_public_place.send(&#34;C&#39;est la nuit, le village s&#39;endort! &#34;+self.vivant.mention)
    await self.channel_recap.send(&#34;Nuit &#34;+str(self.day)+&#34;:&#34;)
    self.day+=1
    for player in self.players:
        await player.nuit(self.channel_public_place)
    if self.lover!=None:
        await self.lover.nuit()</code></pre>
</details>
</dd>
<dt id="botclass.Game.start"><code class="name flex">
<span>def <span class="ident">start</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>set started paramaters to true (the game is started)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start(self):
    &#34;&#34;&#34;set started paramaters to true (the game is started)
    &#34;&#34;&#34;
    self.started=True</code></pre>
</details>
</dd>
<dt id="botclass.Game.vote"><code class="name flex">
<span>async def <span class="ident">vote</span></span>(<span>self, bot)</span>
</code></dt>
<dd>
<div class="desc"><p>does the vote to select the player which will die.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bot</code></strong></dt>
<dd>class discord.ClientUser</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def vote(self,bot):
    &#34;&#34;&#34;does the vote to select the player which will die.
    
    Args:
        bot: class discord.ClientUser
    &#34;&#34;&#34;
    players_alive=[]
    users_alive=[]
    for player in self.players:
        if player.is_alive():
            players_alive.append(player)
            users_alive.append(player.user)
    await self.channel_public_place.send(self.vivant.mention+&#34;,vous allez voter pour la mort d&#39;un membre du village!&#34;)
    await self.channel_polling.send(self.vivant.mention+&#34;,vous allez voter pour la mort d&#39;un membre du village!&#34;)
    message=&#34;&#34;
    for j in range(0,len(players_alive)):
        message=message+emoji[j]+users_alive[j].name+&#34;\n&#34;
    message_vote=await self.channel_polling.send(&#34;Votez pour les personnes qui doivent mourir, parmi:\n&#34;+message)
    for j in range(0,len(players_alive)):
        await message_vote.add_reaction(emoji[j])
    vote=[0 for z in range(0,len(players_alive))]
    await asyncio.sleep(60)
    cache_msg = await self.channel_polling.fetch_message(message_vote.id)
    i=-1
    for reactions in cache_msg.reactions:
        i=i+1
        user_list = [user async for user in reactions.users() if user != bot.user]
        for user in user_list:
            if user in users_alive and i &lt; len(players_alive):
                vote[i]+=1
                if self.with_mayor == True and user == self.mayor.user:
                    vote[i]+=1
    
    m=max(vote)
    im=[a for a, j in enumerate(vote) if j == m]
    if len(im) != 1:
        message=&#34;Egalité, c&#39;est le second round entre\n&#34;
        for j in range (0,len(im)):
            message=message+emoji[j]+users_alive[im[j]].name+&#34;\n&#34;
        message_vote=await self.channel_polling.send(message)
        for j in range (0,len(im)):
            await message_vote.add_reaction(emoji[j])
        vote=[0 for z in range(0,len(im))]
        await asyncio.sleep(60)
        i=-1
        for reactions in cache_msg.reactions:
            i=i+1
            user_list = [user async for user in reactions.users() if user != bot.user]
            for user in user_list:
                if user in users_alive and i &lt; len(im):
                    vote[i]+=1
                    if self.with_mayor == True and user.id == self.mayor.user.id:
                        vote[i]+=1
        m=max(vote)
        print(&#34;vote = &#34;,vote)
        temp=[a for a, j in enumerate(vote) if j == m]
        im2=[]
        for t in temp:
            im2.append(im[t])
        im=im2
    if len(im) ==1:
        message=&#34;Vous avez décidé de pendre &#34;+users_alive[im[0]].name+&#34; !!&#34;
        await self.channel_polling.send(message)
        await self.channel_public_place.send(message)
        im=im[0]
        await players_alive[im].kill(self.channel_public_place,self.channel_graveyard,self.channel_recap,self.vivant,self.mort)
    else:
        message = &#34;Il y a encore égalité, personne ne va mourir.&#34;
        await self.channel_polling.send(message)
        await self.channel_public_place.send(message)</code></pre>
</details>
</dd>
<dt id="botclass.Game.without_mayor"><code class="name flex">
<span>def <span class="ident">without_mayor</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def without_mayor(self):
    self.with_mayor=False</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="botclass.Joueur"><code class="flex name class">
<span>class <span class="ident">Joueur</span></span>
<span>(</span><span>user, role)</span>
</code></dt>
<dd>
<div class="desc"><p>represents a Player</p>
<p>sets the class with is role and the discord user
The player start alive.</p>
<h2 id="args">Args</h2>
<p>user
role</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Joueur:
    &#34;&#34;&#34;represents a Player
    &#34;&#34;&#34;
    def __init__(self,user,role):
        &#34;&#34;&#34;sets the class with is role and the discord user
        The player start alive.

        Args:
            user
            role
        &#34;&#34;&#34;
        self.alive=True
        self.user=user
        self.role=role

    def is_alive(self):
        &#34;&#34;&#34;_summary_

        Returns:
            Bool : True if the player is alive / False if the player is dead
        &#34;&#34;&#34;
        return self.alive

    async def kill(self,channel_public_place,channel_graveyard,channel_recap,vivant,mort):
        &#34;&#34;&#34;Kill the player and uptodate his rigths

        Args:
            channel_public_place
            channel_graveyard
            channel_recap
            vivant : discord role 
            mort : discord role
        &#34;&#34;&#34;
        self.alive=False
        await channel_public_place.set_permissions(self.user, read_messages=True, send_messages=False)
        await self.role.channel.set_permissions(self.user, read_messages=True, send_messages=False)
        await channel_graveyard.set_permissions(self.user, read_messages=True, send_messages=True)
        await channel_public_place.send(self.user.mention+ &#34;est mort, iel était &#34;+self.role.name)
        await channel_recap.send(self.user.mention+ &#34;est mort, iel était &#34;+self.role.name)
        member=await channel_public_place.guild.fetch_member(self.user.id)
        await member.remove_roles(vivant,reason=None)
        await member.add_roles(mort,reason=None)

    async def nuit(self,channel_public_place):
        &#34;&#34;&#34;starts the nigth for the player

        Args:
            channel_public_place
        &#34;&#34;&#34;
        if self.alive==True:
            await self.role.channel.set_permissions(self.user,read_messages=True,send_messages=True)
            await channel_public_place.set_permissions(self.user,read_messages=True,send_messages=False)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="botclass.Joueur.is_alive"><code class="name flex">
<span>def <span class="ident">is_alive</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p><em>summary</em></p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Bool </code></dt>
<dd>True if the player is alive / False if the player is dead</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_alive(self):
    &#34;&#34;&#34;_summary_

    Returns:
        Bool : True if the player is alive / False if the player is dead
    &#34;&#34;&#34;
    return self.alive</code></pre>
</details>
</dd>
<dt id="botclass.Joueur.kill"><code class="name flex">
<span>async def <span class="ident">kill</span></span>(<span>self, channel_public_place, channel_graveyard, channel_recap, vivant, mort)</span>
</code></dt>
<dd>
<div class="desc"><p>Kill the player and uptodate his rigths</p>
<h2 id="args">Args</h2>
<p>channel_public_place
channel_graveyard
channel_recap
vivant : discord role
mort : discord role</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def kill(self,channel_public_place,channel_graveyard,channel_recap,vivant,mort):
    &#34;&#34;&#34;Kill the player and uptodate his rigths

    Args:
        channel_public_place
        channel_graveyard
        channel_recap
        vivant : discord role 
        mort : discord role
    &#34;&#34;&#34;
    self.alive=False
    await channel_public_place.set_permissions(self.user, read_messages=True, send_messages=False)
    await self.role.channel.set_permissions(self.user, read_messages=True, send_messages=False)
    await channel_graveyard.set_permissions(self.user, read_messages=True, send_messages=True)
    await channel_public_place.send(self.user.mention+ &#34;est mort, iel était &#34;+self.role.name)
    await channel_recap.send(self.user.mention+ &#34;est mort, iel était &#34;+self.role.name)
    member=await channel_public_place.guild.fetch_member(self.user.id)
    await member.remove_roles(vivant,reason=None)
    await member.add_roles(mort,reason=None)</code></pre>
</details>
</dd>
<dt id="botclass.Joueur.nuit"><code class="name flex">
<span>async def <span class="ident">nuit</span></span>(<span>self, channel_public_place)</span>
</code></dt>
<dd>
<div class="desc"><p>starts the nigth for the player</p>
<h2 id="args">Args</h2>
<p>channel_public_place</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def nuit(self,channel_public_place):
    &#34;&#34;&#34;starts the nigth for the player

    Args:
        channel_public_place
    &#34;&#34;&#34;
    if self.alive==True:
        await self.role.channel.set_permissions(self.user,read_messages=True,send_messages=True)
        await channel_public_place.set_permissions(self.user,read_messages=True,send_messages=False)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="botclass.Loup"><code class="flex name class">
<span>class <span class="ident">Loup</span></span>
<span>(</span><span>channel)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents the Wolf 'Role'
Composed by :
name (String): the name of the 'Role'
channel (class discord.TextChannel): channel links to the player
side (int): 1 if the role is for the village, -1 if not, 0 if neutral</p>
<p>Initializes the Wolf.
He is against the Village</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code>class discord.TextChannel</code></dt>
<dd>channel links to the player</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Loup(Role):
    &#34;&#34;&#34;
    Represents the Wolf &#39;Role&#39;
    Composed by :
        name (String): the name of the &#39;Role&#39;
        channel (class discord.TextChannel): channel links to the player
        side (int): 1 if the role is for the village, -1 if not, 0 if neutral
    &#34;&#34;&#34;
    
    def __init__(self,channel):
        &#34;&#34;&#34;Initializes the Wolf.
        He is against the Village

        Args:
            channel (class discord.TextChannel): channel links to the player
        &#34;&#34;&#34;
        self.name=&#34;Loup&#34;
        self.channel=channel
        self.side=-1
    async def jour(self,channel_public_place,user):
        &#34;&#34;&#34;set the role for the day
        The Wolf can speak during the day in the public channel. But I can&#39;t speak in his specific channel

        Args:
            channel_public_place (class discord.TextChannel): the public channel of the current game
            user (class discord.User): The user concerned
        &#34;&#34;&#34;
        await self.channel.set_permissions(user,read_messages=True,send_messages=False)
        await channel_public_place.set_permissions(user,read_messages=True,send_messages=True)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="botclass.Role" href="#botclass.Role">Role</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="botclass.Loup.jour"><code class="name flex">
<span>async def <span class="ident">jour</span></span>(<span>self, channel_public_place, user)</span>
</code></dt>
<dd>
<div class="desc"><p>set the role for the day
The Wolf can speak during the day in the public channel. But I can't speak in his specific channel</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>channel_public_place</code></strong> :&ensp;<code>class discord.TextChannel</code></dt>
<dd>the public channel of the current game</dd>
<dt><strong><code>user</code></strong> :&ensp;<code>class discord.User</code></dt>
<dd>The user concerned</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def jour(self,channel_public_place,user):
    &#34;&#34;&#34;set the role for the day
    The Wolf can speak during the day in the public channel. But I can&#39;t speak in his specific channel

    Args:
        channel_public_place (class discord.TextChannel): the public channel of the current game
        user (class discord.User): The user concerned
    &#34;&#34;&#34;
    await self.channel.set_permissions(user,read_messages=True,send_messages=False)
    await channel_public_place.set_permissions(user,read_messages=True,send_messages=True)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="botclass.Lover"><code class="flex name class">
<span>class <span class="ident">Lover</span></span>
<span>(</span><span>player1, player2, channel)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents a couple
Composed by :
channel (class discord.TextChannel): channel links to the couple
player1 &amp; player2 (class discord.member) : which are the two member of the couple</p>
<p>initializes the couple</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code>class discord.TextChannel</code></dt>
<dd>channel links to the couple</dd>
</dl>
<p>player1 &amp; player2 (class discord.member) : which are the two member of the couple
return: Nothing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Lover():
    &#34;&#34;&#34;
    Represents a couple 
    Composed by :
        channel (class discord.TextChannel): channel links to the couple
        player1 &amp; player2 (class discord.member) : which are the two member of the couple
    &#34;&#34;&#34;
    def __init__(self,player1,player2,channel):
        &#34;&#34;&#34;initializes the couple
        
        Args:
            channel (class discord.TextChannel): channel links to the couple
            player1 &amp; player2 (class discord.member) : which are the two member of the couple
        return: Nothing
        &#34;&#34;&#34;
        self.player1=player1
        self.player2=player2
        self.channel=channel
    async def check_death(self,channel_public_place,channel_graveyard,channel_recap,vivant,mort):
        &#34;&#34;&#34;This function check if one member of the couple is dead or not. If he is, the other member die too.

        Args:
            channel_public_place
            channel_graveyard
            channel_recap
            vivant : discord role (living person)
            mort : discord role (dead person)
        &#34;&#34;&#34;
        if not(self.player1.is_alive()) and self.player2.is_alive():
            await channel_public_place.send(self.player2.user.mention+&#34; était amoureux de &#34;+self.player1.user.mention)
            await channel_recap.send(self.player2.user.mention+&#34; était amoureux de &#34;+self.player1.user.mention)
            await self.player2.kill(channel_public_place,channel_graveyard,channel_recap,vivant,mort)
        elif self.player1.is_alive() and not(self.player2.is_alive()):
            await channel_public_place.send(self.player1.user.mention+&#34; était amoureux de &#34;+self.player2.user.mention)
            await channel_recap.send(self.player1.user.mention+&#34; était amoureux de &#34;+self.player2.user.mention)
            await self.player1.kill(channel_public_place,channel_graveyard,channel_recap,vivant,mort)
    async def nuit(self):
        &#34;&#34;&#34;set the couple for the night
        The couple can speak during the night in their own channel
        &#34;&#34;&#34;
        if self.player1.is_alive() and self.player2.is_alive():
            await self.channel.set_permissions(self.player1.user,read_messages=True, send_messages=True)
            await self.channel.set_permissions(self.player2.user,read_messages=True, send_messages=True)
    async def jour(self):
        &#34;&#34;&#34;set the couple for the night
        The couple can speak during the night in their own channel
        &#34;&#34;&#34;
        await self.channel.set_permissions(self.player1.user,read_messages=True, send_messages=False)
        await self.channel.set_permissions(self.player2.user,read_messages=True, send_messages=False)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="botclass.Lover.check_death"><code class="name flex">
<span>async def <span class="ident">check_death</span></span>(<span>self, channel_public_place, channel_graveyard, channel_recap, vivant, mort)</span>
</code></dt>
<dd>
<div class="desc"><p>This function check if one member of the couple is dead or not. If he is, the other member die too.</p>
<h2 id="args">Args</h2>
<p>channel_public_place
channel_graveyard
channel_recap
vivant : discord role (living person)
mort : discord role (dead person)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def check_death(self,channel_public_place,channel_graveyard,channel_recap,vivant,mort):
    &#34;&#34;&#34;This function check if one member of the couple is dead or not. If he is, the other member die too.

    Args:
        channel_public_place
        channel_graveyard
        channel_recap
        vivant : discord role (living person)
        mort : discord role (dead person)
    &#34;&#34;&#34;
    if not(self.player1.is_alive()) and self.player2.is_alive():
        await channel_public_place.send(self.player2.user.mention+&#34; était amoureux de &#34;+self.player1.user.mention)
        await channel_recap.send(self.player2.user.mention+&#34; était amoureux de &#34;+self.player1.user.mention)
        await self.player2.kill(channel_public_place,channel_graveyard,channel_recap,vivant,mort)
    elif self.player1.is_alive() and not(self.player2.is_alive()):
        await channel_public_place.send(self.player1.user.mention+&#34; était amoureux de &#34;+self.player2.user.mention)
        await channel_recap.send(self.player1.user.mention+&#34; était amoureux de &#34;+self.player2.user.mention)
        await self.player1.kill(channel_public_place,channel_graveyard,channel_recap,vivant,mort)</code></pre>
</details>
</dd>
<dt id="botclass.Lover.jour"><code class="name flex">
<span>async def <span class="ident">jour</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>set the couple for the night
The couple can speak during the night in their own channel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def jour(self):
    &#34;&#34;&#34;set the couple for the night
    The couple can speak during the night in their own channel
    &#34;&#34;&#34;
    await self.channel.set_permissions(self.player1.user,read_messages=True, send_messages=False)
    await self.channel.set_permissions(self.player2.user,read_messages=True, send_messages=False)</code></pre>
</details>
</dd>
<dt id="botclass.Lover.nuit"><code class="name flex">
<span>async def <span class="ident">nuit</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>set the couple for the night
The couple can speak during the night in their own channel</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def nuit(self):
    &#34;&#34;&#34;set the couple for the night
    The couple can speak during the night in their own channel
    &#34;&#34;&#34;
    if self.player1.is_alive() and self.player2.is_alive():
        await self.channel.set_permissions(self.player1.user,read_messages=True, send_messages=True)
        await self.channel.set_permissions(self.player2.user,read_messages=True, send_messages=True)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="botclass.Petite_fille"><code class="flex name class">
<span>class <span class="ident">Petite_fille</span></span>
<span>(</span><span>channel)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents the Little girl 'Role'
Composed by :
name (String): the name of the 'Role'
channel (class discord.TextChannel): channel links to the player
side (int) : 1 if the role is for the village, -1 if not, 0 if neutral
deja_lu (int) : the last message read from the wolf's channel</p>
<p>Initializes the Little girl.
She is with the Village</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code>class discord.TextChannel</code></dt>
<dd>channel links to the player</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Petite_fille(Role):
    &#34;&#34;&#34;
    Represents the Little girl &#39;Role&#39;
    Composed by :
        name (String): the name of the &#39;Role&#39;
        channel (class discord.TextChannel): channel links to the player
        side (int) : 1 if the role is for the village, -1 if not, 0 if neutral
        deja_lu (int) : the last message read from the wolf&#39;s channel
    &#34;&#34;&#34;
    def __init__(self,channel):
        &#34;&#34;&#34;Initializes the Little girl.
        She is with the Village

        Args:
            channel (class discord.TextChannel): channel links to the player
        &#34;&#34;&#34;
        self.name=&#34;Petite Fille&#34;
        self.channel=channel
        self.side=1
        self.deja_lu=0
    async def action(self,game):
        &#34;&#34;&#34;start the turn of the Little girl.
        She can ask to know what the wolf are saying with the command &#39;!ecoute&#39;
        Args:
            game (class Game): The current game party
            
        return: Nothing
        &#34;&#34;&#34;
        players=game.players
        chan_loup=None
        for player in players:
            if player.role.name==&#34;Loup&#34;:
                chan_loup=player.role.channel
        if chan_loup==None:
            await self.channel.send(&#34;Il n&#39;y a pas de loup à écouter&#34;)
        else:
            messages=await chan_loup.history(limit = 1000).flatten()
            messages.reverse()
            loup=None
            for message in messages:
                if message.author.name != &#34;GarouBOT&#34;:
                    if message.id &gt; self.deja_lu:
                        if loup != message.author:
                                loup=message.author
                                await self.channel.send(&#34;```    Un loup dit:```&#34;)
                        await self.channel.send(message.content)  
            self.deja_lu=message.id
            print(&#34;ecoute fin&#34;)
            await self.channel.send(&#34;```Tu as tout entendu pour l&#39;instant```&#34;)
    async def jour(self,channel_public_place,user):
        &#34;&#34;&#34;set the role for the day
        The Little girl can speak during the day in the public channel.

        Args:
            channel_public_place (class discord.TextChannel): the public channel of the current game
            user (class discord.User): The user concerned
        &#34;&#34;&#34;
        await channel_public_place.set_permissions(user,read_messages=True,send_messages=True)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="botclass.Role" href="#botclass.Role">Role</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="botclass.Petite_fille.action"><code class="name flex">
<span>async def <span class="ident">action</span></span>(<span>self, game)</span>
</code></dt>
<dd>
<div class="desc"><p>start the turn of the Little girl.
She can ask to know what the wolf are saying with the command '!ecoute'</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>game</code></strong> :&ensp;<code>class <a title="botclass.Game" href="#botclass.Game">Game</a></code></dt>
<dd>The current game party</dd>
</dl>
<p>return: Nothing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def action(self,game):
    &#34;&#34;&#34;start the turn of the Little girl.
    She can ask to know what the wolf are saying with the command &#39;!ecoute&#39;
    Args:
        game (class Game): The current game party
        
    return: Nothing
    &#34;&#34;&#34;
    players=game.players
    chan_loup=None
    for player in players:
        if player.role.name==&#34;Loup&#34;:
            chan_loup=player.role.channel
    if chan_loup==None:
        await self.channel.send(&#34;Il n&#39;y a pas de loup à écouter&#34;)
    else:
        messages=await chan_loup.history(limit = 1000).flatten()
        messages.reverse()
        loup=None
        for message in messages:
            if message.author.name != &#34;GarouBOT&#34;:
                if message.id &gt; self.deja_lu:
                    if loup != message.author:
                            loup=message.author
                            await self.channel.send(&#34;```    Un loup dit:```&#34;)
                    await self.channel.send(message.content)  
        self.deja_lu=message.id
        print(&#34;ecoute fin&#34;)
        await self.channel.send(&#34;```Tu as tout entendu pour l&#39;instant```&#34;)</code></pre>
</details>
</dd>
<dt id="botclass.Petite_fille.jour"><code class="name flex">
<span>async def <span class="ident">jour</span></span>(<span>self, channel_public_place, user)</span>
</code></dt>
<dd>
<div class="desc"><p>set the role for the day
The Little girl can speak during the day in the public channel.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>channel_public_place</code></strong> :&ensp;<code>class discord.TextChannel</code></dt>
<dd>the public channel of the current game</dd>
<dt><strong><code>user</code></strong> :&ensp;<code>class discord.User</code></dt>
<dd>The user concerned</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def jour(self,channel_public_place,user):
    &#34;&#34;&#34;set the role for the day
    The Little girl can speak during the day in the public channel.

    Args:
        channel_public_place (class discord.TextChannel): the public channel of the current game
        user (class discord.User): The user concerned
    &#34;&#34;&#34;
    await channel_public_place.set_permissions(user,read_messages=True,send_messages=True)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="botclass.Role"><code class="flex name class">
<span>class <span class="ident">Role</span></span>
</code></dt>
<dd>
<div class="desc"><p>Role is representing all the different kind of possible Role
(virtual class)
Composed at least by
name (String) : the name of the 'Role'
channel (class discord.TextChannel) : channel links to the player
side (int) : 1 if the role is for the village, 0 if not</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Role:
    &#34;&#34;&#34;
    Role is representing all the different kind of possible Role
    (virtual class)
    Composed at least by
        name (String) : the name of the &#39;Role&#39;
        channel (class discord.TextChannel) : channel links to the player
        side (int) : 1 if the role is for the village, 0 if not
    &#34;&#34;&#34;
    def __init__(self) -&gt; None:
        pass</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="botclass.Chasseur" href="#botclass.Chasseur">Chasseur</a></li>
<li><a title="botclass.Cupidon" href="#botclass.Cupidon">Cupidon</a></li>
<li><a title="botclass.Loup" href="#botclass.Loup">Loup</a></li>
<li><a title="botclass.Petite_fille" href="#botclass.Petite_fille">Petite_fille</a></li>
<li><a title="botclass.Salvateur" href="#botclass.Salvateur">Salvateur</a></li>
<li><a title="botclass.Soeur" href="#botclass.Soeur">Soeur</a></li>
<li><a title="botclass.Sorcière" href="#botclass.Sorcière">Sorcière</a></li>
<li><a title="botclass.Villageois" href="#botclass.Villageois">Villageois</a></li>
<li><a title="botclass.Voyante" href="#botclass.Voyante">Voyante</a></li>
</ul>
</dd>
<dt id="botclass.Salvateur"><code class="flex name class">
<span>class <span class="ident">Salvateur</span></span>
<span>(</span><span>channel)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents the Salvateur'
Composed by :
name (String): the name of the 'Role'
channel (class discord.TextChannel): channel links to the player
side (int) : 1 if the role is for the village, -1 if not, 0 if neutral
self.previous_night (class discord.user) : last personn he protected</p>
<p>Initializes the Salvateur.
He is with the Village
He can protect every nigth someone (can't be the same personn two following night)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code>class discord.TextChannel</code></dt>
<dd>channel links to the player</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Salvateur(Role):
    &#34;&#34;&#34;
    Represents the Salvateur&#39;
    Composed by :
        name (String): the name of the &#39;Role&#39;
        channel (class discord.TextChannel): channel links to the player
        side (int) : 1 if the role is for the village, -1 if not, 0 if neutral
        self.previous_night (class discord.user) : last personn he protected
    &#34;&#34;&#34;
    def __init__(self,channel):
        &#34;&#34;&#34;Initializes the Salvateur.
        He is with the Village
        He can protect every nigth someone (can&#39;t be the same personn two following night)

        Args:
            channel (class discord.TextChannel): channel links to the player
        &#34;&#34;&#34;
        self.name=&#34;Salvateur&#34;
        self.channel=channel
        self.side=1
        self.previous_night=None
    async def jour(self,channel_public_place,user):
        &#34;&#34;&#34;set the role for the day
        The Salvateur can speak during the day in the public channel.
        She can speak to her Sister during the night
    
        Args:
            channel_public_place (class discord.TextChannel): the public channel of the current game
            user (class discord.User): The user concerned
        &#34;&#34;&#34;
        await channel_public_place.set_permissions(user,read_messages=True,send_messages=True)
    async def action(self,game,bot):
        &#34;&#34;&#34;start the turn of the Salvateur.
        Choose someone to protect.
        
        Args:
            game (class Game): The current game party
            
        return: Nothing
        &#34;&#34;&#34;
        players_alive=[]
        salvateur=None
        players=game.players
        for player in players:
            if player.is_alive():
                if  player.role.name==&#34;Salvateur&#34;:
                    salvateur=player
                players_alive.append(player)
    
        message=&#34;&#34;
        i=0
        for player in players_alive:
            message=message+ emoji[i] + player.user.name+&#39;\n&#39;
            i=i+1

        message_voyante=await self.channel.send(salvateur.user.mention+&#34;! Salut Salvateur, tu dois choisir qui proteger cette nuit (pas deux fois de suite la même personne):\n&#34;+message)
        def checkVoyante(reaction,user):
            if user==salvateur.user and reaction.message.id == message_voyante.id and (str(reaction.emoji) == &#39;✅&#39; or str(reaction.emoji) ==&#39;❌&#39;):
                return(True)
            return(False)

        for j in range(0,i):
            await message_voyante.add_reaction(emoji[j])
        await message_voyante.add_reaction(&#39;✅&#39;)
        protect=[]
        try:
            await bot.wait_for(&#34;reaction_add&#34;, timeout=60, check=checkVoyante)
        except asyncio.TimeoutError:
            await self.channel.send(&#34;Le temps est dépassé ou le choix est erroné, le choix sera donc aléatoire&#34;)
        cache_msg = await message_voyante.channel.fetch_message(message_voyante.id)
        i=-1
        
        for reactions in cache_msg.reactions:
            i=i+1
            user_list = [user async for user in reactions.users() if user != bot.user]
            
            for user in user_list:
                if user==salvateur.user and i &lt; len(players_alive):
                    protect.append(players_alive[i])
        if len(protect) !=1:
            protect=[players_alive[random.randint(0,len(players_alive)-1)]]
        while protect[0] == self.previous_night: #on regarde si c&#39;est la meme personne que la nuit précedente
            await self.channel.send(&#34;Le choix est identique à la nuit précedente, on fait aléatoirement&#34;)
            protect=[players_alive[random.randint(0,len(players_alive)-1)]]
        
        #si il a proteger le mort alors on enleve le mort
        j=0
        print(&#34;protect =&#34;,protect[0])
        print(&#34;death =&#34;,game.night_death)
        for i in range (0,len(game.night_death)):
            if game.night_death[i-j] == protect[0]:
                game.night_death.pop(i-j)
                j+=1

        self.previous_night=protect[0]
        await self.channel.send(protect[0].user.name+&#34; va être protèger cette nuit !&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="botclass.Role" href="#botclass.Role">Role</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="botclass.Salvateur.action"><code class="name flex">
<span>async def <span class="ident">action</span></span>(<span>self, game, bot)</span>
</code></dt>
<dd>
<div class="desc"><p>start the turn of the Salvateur.
Choose someone to protect.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>game</code></strong> :&ensp;<code>class <a title="botclass.Game" href="#botclass.Game">Game</a></code></dt>
<dd>The current game party</dd>
</dl>
<p>return: Nothing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def action(self,game,bot):
    &#34;&#34;&#34;start the turn of the Salvateur.
    Choose someone to protect.
    
    Args:
        game (class Game): The current game party
        
    return: Nothing
    &#34;&#34;&#34;
    players_alive=[]
    salvateur=None
    players=game.players
    for player in players:
        if player.is_alive():
            if  player.role.name==&#34;Salvateur&#34;:
                salvateur=player
            players_alive.append(player)

    message=&#34;&#34;
    i=0
    for player in players_alive:
        message=message+ emoji[i] + player.user.name+&#39;\n&#39;
        i=i+1

    message_voyante=await self.channel.send(salvateur.user.mention+&#34;! Salut Salvateur, tu dois choisir qui proteger cette nuit (pas deux fois de suite la même personne):\n&#34;+message)
    def checkVoyante(reaction,user):
        if user==salvateur.user and reaction.message.id == message_voyante.id and (str(reaction.emoji) == &#39;✅&#39; or str(reaction.emoji) ==&#39;❌&#39;):
            return(True)
        return(False)

    for j in range(0,i):
        await message_voyante.add_reaction(emoji[j])
    await message_voyante.add_reaction(&#39;✅&#39;)
    protect=[]
    try:
        await bot.wait_for(&#34;reaction_add&#34;, timeout=60, check=checkVoyante)
    except asyncio.TimeoutError:
        await self.channel.send(&#34;Le temps est dépassé ou le choix est erroné, le choix sera donc aléatoire&#34;)
    cache_msg = await message_voyante.channel.fetch_message(message_voyante.id)
    i=-1
    
    for reactions in cache_msg.reactions:
        i=i+1
        user_list = [user async for user in reactions.users() if user != bot.user]
        
        for user in user_list:
            if user==salvateur.user and i &lt; len(players_alive):
                protect.append(players_alive[i])
    if len(protect) !=1:
        protect=[players_alive[random.randint(0,len(players_alive)-1)]]
    while protect[0] == self.previous_night: #on regarde si c&#39;est la meme personne que la nuit précedente
        await self.channel.send(&#34;Le choix est identique à la nuit précedente, on fait aléatoirement&#34;)
        protect=[players_alive[random.randint(0,len(players_alive)-1)]]
    
    #si il a proteger le mort alors on enleve le mort
    j=0
    print(&#34;protect =&#34;,protect[0])
    print(&#34;death =&#34;,game.night_death)
    for i in range (0,len(game.night_death)):
        if game.night_death[i-j] == protect[0]:
            game.night_death.pop(i-j)
            j+=1

    self.previous_night=protect[0]
    await self.channel.send(protect[0].user.name+&#34; va être protèger cette nuit !&#34;)</code></pre>
</details>
</dd>
<dt id="botclass.Salvateur.jour"><code class="name flex">
<span>async def <span class="ident">jour</span></span>(<span>self, channel_public_place, user)</span>
</code></dt>
<dd>
<div class="desc"><p>set the role for the day
The Salvateur can speak during the day in the public channel.
She can speak to her Sister during the night</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>channel_public_place</code></strong> :&ensp;<code>class discord.TextChannel</code></dt>
<dd>the public channel of the current game</dd>
<dt><strong><code>user</code></strong> :&ensp;<code>class discord.User</code></dt>
<dd>The user concerned</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def jour(self,channel_public_place,user):
    &#34;&#34;&#34;set the role for the day
    The Salvateur can speak during the day in the public channel.
    She can speak to her Sister during the night

    Args:
        channel_public_place (class discord.TextChannel): the public channel of the current game
        user (class discord.User): The user concerned
    &#34;&#34;&#34;
    await channel_public_place.set_permissions(user,read_messages=True,send_messages=True)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="botclass.Soeur"><code class="flex name class">
<span>class <span class="ident">Soeur</span></span>
<span>(</span><span>channel)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents the Sister 'Role'
Composed by :
name (String): the name of the 'Role'
channel (class discord.TextChannel): channel links to the player
side (int) : 1 if the role is for the village, -1 if not, 0 if neutral</p>
<p>Initializes the Sister.
She is with the Village
She can speak to her Sister during the night</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code>class discord.TextChannel</code></dt>
<dd>channel links to the player</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Soeur(Role):
    &#34;&#34;&#34;
    Represents the Sister &#39;Role&#39;
    Composed by :
        name (String): the name of the &#39;Role&#39;
        channel (class discord.TextChannel): channel links to the player
        side (int) : 1 if the role is for the village, -1 if not, 0 if neutral
    &#34;&#34;&#34;
    def __init__(self,channel):
        &#34;&#34;&#34;Initializes the Sister.
        She is with the Village
        She can speak to her Sister during the night

        Args:
            channel (class discord.TextChannel): channel links to the player
        &#34;&#34;&#34;
        self.name=&#34;Soeur&#34;
        self.channel=channel
        self.side=1
    async def jour(self,channel_public_place,user):
        &#34;&#34;&#34;set the role for the day
        The Sister can speak during the day in the public channel.
        She can speak to her Sister during the night
    
        Args:
            channel_public_place (class discord.TextChannel): the public channel of the current game
            user (class discord.User): The user concerned
        &#34;&#34;&#34;
        await self.channel.set_permissions(user,read_messages=True,send_messages=False)
        await channel_public_place.set_permissions(user,read_messages=True,send_messages=True)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="botclass.Role" href="#botclass.Role">Role</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="botclass.Soeur.jour"><code class="name flex">
<span>async def <span class="ident">jour</span></span>(<span>self, channel_public_place, user)</span>
</code></dt>
<dd>
<div class="desc"><p>set the role for the day
The Sister can speak during the day in the public channel.
She can speak to her Sister during the night</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>channel_public_place</code></strong> :&ensp;<code>class discord.TextChannel</code></dt>
<dd>the public channel of the current game</dd>
<dt><strong><code>user</code></strong> :&ensp;<code>class discord.User</code></dt>
<dd>The user concerned</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def jour(self,channel_public_place,user):
    &#34;&#34;&#34;set the role for the day
    The Sister can speak during the day in the public channel.
    She can speak to her Sister during the night

    Args:
        channel_public_place (class discord.TextChannel): the public channel of the current game
        user (class discord.User): The user concerned
    &#34;&#34;&#34;
    await self.channel.set_permissions(user,read_messages=True,send_messages=False)
    await channel_public_place.set_permissions(user,read_messages=True,send_messages=True)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="botclass.Sorcière"><code class="flex name class">
<span>class <span class="ident">Sorcière</span></span>
<span>(</span><span>channel)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents the Witch 'Role'
Composed by :
name (String): the name of the 'Role'
channel (class discord.TextChannel): channel links to the player
side (int): 1 if the role is for the village, -1 if not, 0 if neutral
heal (Boolean): True if the Witch steal has her heal potion
kill (Boolean): True if the Witch steal has her death potion</p>
<p>Initializes the Witch.
The Witch starts with one heal and one death potions. She is with the Village</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code>class discord.TextChannel</code></dt>
<dd>channel links to the player</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Sorcière(Role):
    &#34;&#34;&#34;
    Represents the Witch &#39;Role&#39;
    Composed by :
        name (String): the name of the &#39;Role&#39;
        channel (class discord.TextChannel): channel links to the player
        side (int): 1 if the role is for the village, -1 if not, 0 if neutral
        heal (Boolean): True if the Witch steal has her heal potion
        kill (Boolean): True if the Witch steal has her death potion
    &#34;&#34;&#34;
    def __init__(self,channel):
        &#34;&#34;&#34;Initializes the Witch.
        The Witch starts with one heal and one death potions. She is with the Village

        Args:
            channel (class discord.TextChannel): channel links to the player
        &#34;&#34;&#34;
        self.name=&#34;Sorcière&#34;
        self.channel=channel
        self.heal=True
        self.kill=True
        self.side=1
        
    async def action(self,game,bot):
        &#34;&#34;&#34;start the turn of the Witch.
        The Witcher has maximum 3 possibilities:
        -Use heal potion to save the wolf&#39;s dead  [Can be done one time]
        -Use death potion to kill someone (She chooses the Player) [Can be done one time]
        -Do nothing

        Args:
            game (class Game): The current game party
            bot (class Bot): The current bot
            
        return: Nothing
        &#34;&#34;&#34;
        sorciere=None
        non_sorciere=[]
        mort_soso=[]
        players=game.players
        for player in players:
            if player.role.name==&#34;Sorcière&#34;:
                sorciere=player
            else:
                non_sorciere.append(player)
        
        if len(game.night_death)==1 and self.heal==True and self.kill==True:
            mort_loup=game.night_death[0].user
            mes=sorciere.user.mention+&#34; Salut sorcière ! Cette nuit, quelqu&#39;un va mourir. Il s&#39;agit de &#34;+mort_loup.name+&#34; tu as le choix entre:\n    ⚕️ la ressuciter\n    💀 tuer quelqu&#39;un\n    💤 ne rien faire&#34;
            message_sorciere=await self.channel.send(mes)
            await message_sorciere.add_reaction(&#39;⚕️&#39;)
            await message_sorciere.add_reaction(&#39;💀&#39;)
            await message_sorciere.add_reaction(&#39;💤&#39;)
            await message_sorciere.add_reaction(&#39;✅&#39;)
            
            choix=[]
            def checkSosoAction(reaction,user):
                if user == sorciere.user and reaction.message.id == message_sorciere.id and str(reaction.emoji) == &#39;✅&#39; :
                    return(True)
                return(False)
            try:
                await bot.wait_for(&#34;reaction_add&#34;, timeout=1*60, check=checkSosoAction)
                cache_msg = await message_sorciere.channel.fetch_message(message_sorciere.id)
                i=-1
                for reactions in cache_msg.reactions:
                    i=i+1
                    user_list = [user async for user in reactions.users() if user != bot.user]
                    
                    for user in user_list:
                        if user==sorciere.user and i &lt; 3:
                            choix.append(i)
            except asyncio.TimeoutError:
                await self.channel.send(&#34;Le temps est dépassé, le choix sera aléatoire&#34;)
                choix=[random.randint(0,2)]
            if len(choix) !=1:
                choix=[random.randint(0,2)]
                await self.channel.send(&#34;C&#39;est interdit, le choix sera aléatoire&#34;)
            if choix[0]== 0:#on sauve
                game.night_death.pop(0)
                self.heal=False
                await self.channel.send(&#34;Tu es une personne bien, la victime survivra.&#34;)
            elif choix[0] == 1: #on tue
                message=&#34;Tu veux donc tuer quelqu&#39;un, qui va devoir boire ta fameuse potion ??:\n&#34;
                i=0
                for j in non_sorciere:
                    message=message+ emoji[i] + j.user.name+&#39;\n&#39;
                    i=i+1
                message_sorciere = await self.channel.send(message)
        
                for j in range(0,i):
                    await message_sorciere.add_reaction(emoji[j])
                await message_sorciere.add_reaction(&#39;✅&#39;)
                try:
                    await bot.wait_for(&#34;reaction_add&#34;, timeout=1*60, check=checkSosoAction)
                except asyncio.TimeoutError:
                    await self.channel.send(&#34;Le temps est dépassé, le choix sera aléatoire&#34;)
                    mort_soso.append(random.randint(0,len(non_sorciere)))
                cache_msg = await message_sorciere.channel.fetch_message(message_sorciere.id)
                i=-1
                for reactions in cache_msg.reactions:
                    i=i+1
                    user_list = [user async for user in reactions.users() if user != bot.user]
                    
                    for user in user_list:
                        if user == sorciere.user and i &lt; len(non_sorciere):
                            mort_soso.append(i)
                if (len(mort_soso)!=1):
                    mort_soso.append(random.randint(0,len(non_sorciere)))
                mort_soso=non_sorciere[mort_soso[0]]
                await self.channel.send(&#34;Très bien, &#34;+mort_soso.user.name+&#34; va mourir&#34;)
                self.kill=False
        elif len(game.night_death)==1 and self.heal==True and self.kill==False:
            mort_loup=game.night_death[0].user
            mes=sorciere.user.mention+&#34; Salut sorcière cette nuit, quelqu&#39;un va mourir. Il s&#39;agit de **&#34;+mort_loup.name+&#34;** tu as le choix entre:\n    ⚕️ la ressuciter\n    💤 ne rien faire&#34;
            message_sorciere=await self.channel.send(mes)
            await message_sorciere.add_reaction(&#39;⚕️&#39;)
            await message_sorciere.add_reaction(&#39;💤&#39;)
            await message_sorciere.add_reaction(&#39;✅&#39;)
            
            choix=[]
            def checkSosoAction(reaction,user):
                if user == sorciere.user and reaction.message.id == message_sorciere.id and str(reaction.emoji) == &#39;✅&#39; :
                    return(True)
                return(False)
            try:
                await bot.wait_for(&#34;reaction_add&#34;, timeout=1*60, check=checkSosoAction)
                cache_msg = await message_sorciere.channel.fetch_message(message_sorciere.id)
                i=-1
                for reactions in cache_msg.reactions:
                    i=i+1
                    user_list = [user async for user in reactions.users() if user != bot.user]
                    
                    for user in user_list:
                        if user==sorciere.user and i &lt; 2:
                            choix.append(i)
            except asyncio.TimeoutError:
                await self.channel.send(&#34;Le temps est dépassé, le choix sera aléatoire&#34;)
                choix=[random.randint(0,1)]
            if len(choix) !=1:
                choix=[random.randint(0,1)]
                await self.channel.send(&#34;C&#39;est interdit, le choix sera aléatoire&#34;)
            if choix[0]== 0:#on sauve
                un_mort_loup=False
                await self.channel.send(&#34;Tu es une personne bien, la victime survivra.&#34;)
                self.heal=False
        elif self.kill == True:
            mes=sorciere.user.mention+&#34; Salut sorcière, tu as le choix entre:\n    💀 tuer quelqu&#39;un\n    💤 ne rien faire&#34;
            message_sorciere=await self.channel.send(mes)
            await message_sorciere.add_reaction(&#39;💀&#39;)
            await message_sorciere.add_reaction(&#39;💤&#39;)
            await message_sorciere.add_reaction(&#39;✅&#39;)
            
            choix=[]
            def checkSosoAction(reaction,user):
                if user == sorciere.user and reaction.message.id == message_sorciere.id and str(reaction.emoji) == &#39;✅&#39; :
                    return(True)
                return(False)
            try:
                await bot.wait_for(&#34;reaction_add&#34;, timeout=1*60, check=checkSosoAction)
                cache_msg = await message_sorciere.channel.fetch_message(message_sorciere.id)
                i=-1
                for reactions in cache_msg.reactions:
                    i=i+1
                    user_list = [user async for user in reactions.users() if user != bot.user]
                    
                    for user in user_list:
                        if user==sorciere.user and i &lt; 2:
                            choix.append(i)
            except asyncio.TimeoutError:
                await self.channel.send(&#34;Le temps est dépasser, le choix sera aléatoire&#34;)
                choix=[random.randint(0,1)]
            if len(choix) !=1:
                choix=[random.randint(0,1)]
                await self.channel.send(&#34;C&#39;est interdit, le choix sera aléatoire&#34;)
            if choix[0] == 0: #on tue
                message=&#34;Tu veux donc tuer quelqu&#39;un, qui va devoir boire ta fameuse potion ??:\n&#34;
                i=0
                for j in non_sorciere:
                    message=message+ emoji[i] + j.user.name+&#39;\n&#39;
                    i=i+1
                message_sorciere = await self.channel.send(message)
        
                for j in range(0,i):
                    await message_sorciere.add_reaction(emoji[j])
                await message_sorciere.add_reaction(&#39;✅&#39;)
                
                try:
                    await bot.wait_for(&#34;reaction_add&#34;, timeout=1*60, check=checkSosoAction)
                except asyncio.TimeoutError:
                    await self.channel.send(&#34;Le temps est dépassé, le choix sera aléatoire&#34;)
                    mort_soso.append(random.randint(0,len(non_sorciere)))
                cache_msg = await message_sorciere.channel.fetch_message(message_sorciere.id)
                i=-1
                for reactions in cache_msg.reactions:
                    i=i+1
                    user_list = [user async for user in reactions.users() if user != bot.user]
                    
                    for user in user_list:
                        if user == sorciere.user and i &lt; len(non_sorciere):
                            mort_soso.append(i)
                if (len(mort_soso)!=1):
                    mort_soso.append(random.randint(0,len(non_sorciere)))
                mort_soso=non_sorciere[mort_soso[0]]
                await self.channel.send(&#34;Très bien, &#34;+mort_soso.user.name+&#34; va mourir&#34;)
                self.kill=False
                game.night_death.append(mort_soso)
        await self.channel.send(&#34;Bonne nuit la sorcière&#34;)
    
    async def jour(self,channel_public_place,user):
        &#34;&#34;&#34;set the role for the day
        The Witch can speak during the day in the public channel

        Args:
            channel_public_place (class discord.TextChannel): the public channel of the current game
            user (class discord.User): The user concerned
        &#34;&#34;&#34;
        await channel_public_place.set_permissions(user,read_messages=True,send_messages=True)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="botclass.Role" href="#botclass.Role">Role</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="botclass.Sorcière.action"><code class="name flex">
<span>async def <span class="ident">action</span></span>(<span>self, game, bot)</span>
</code></dt>
<dd>
<div class="desc"><p>start the turn of the Witch.
The Witcher has maximum 3 possibilities:
-Use heal potion to save the wolf's dead
[Can be done one time]
-Use death potion to kill someone (She chooses the Player) [Can be done one time]
-Do nothing</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>game</code></strong> :&ensp;<code>class <a title="botclass.Game" href="#botclass.Game">Game</a></code></dt>
<dd>The current game party</dd>
<dt><strong><code>bot</code></strong> :&ensp;<code>class Bot</code></dt>
<dd>The current bot</dd>
</dl>
<p>return: Nothing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def action(self,game,bot):
    &#34;&#34;&#34;start the turn of the Witch.
    The Witcher has maximum 3 possibilities:
    -Use heal potion to save the wolf&#39;s dead  [Can be done one time]
    -Use death potion to kill someone (She chooses the Player) [Can be done one time]
    -Do nothing

    Args:
        game (class Game): The current game party
        bot (class Bot): The current bot
        
    return: Nothing
    &#34;&#34;&#34;
    sorciere=None
    non_sorciere=[]
    mort_soso=[]
    players=game.players
    for player in players:
        if player.role.name==&#34;Sorcière&#34;:
            sorciere=player
        else:
            non_sorciere.append(player)
    
    if len(game.night_death)==1 and self.heal==True and self.kill==True:
        mort_loup=game.night_death[0].user
        mes=sorciere.user.mention+&#34; Salut sorcière ! Cette nuit, quelqu&#39;un va mourir. Il s&#39;agit de &#34;+mort_loup.name+&#34; tu as le choix entre:\n    ⚕️ la ressuciter\n    💀 tuer quelqu&#39;un\n    💤 ne rien faire&#34;
        message_sorciere=await self.channel.send(mes)
        await message_sorciere.add_reaction(&#39;⚕️&#39;)
        await message_sorciere.add_reaction(&#39;💀&#39;)
        await message_sorciere.add_reaction(&#39;💤&#39;)
        await message_sorciere.add_reaction(&#39;✅&#39;)
        
        choix=[]
        def checkSosoAction(reaction,user):
            if user == sorciere.user and reaction.message.id == message_sorciere.id and str(reaction.emoji) == &#39;✅&#39; :
                return(True)
            return(False)
        try:
            await bot.wait_for(&#34;reaction_add&#34;, timeout=1*60, check=checkSosoAction)
            cache_msg = await message_sorciere.channel.fetch_message(message_sorciere.id)
            i=-1
            for reactions in cache_msg.reactions:
                i=i+1
                user_list = [user async for user in reactions.users() if user != bot.user]
                
                for user in user_list:
                    if user==sorciere.user and i &lt; 3:
                        choix.append(i)
        except asyncio.TimeoutError:
            await self.channel.send(&#34;Le temps est dépassé, le choix sera aléatoire&#34;)
            choix=[random.randint(0,2)]
        if len(choix) !=1:
            choix=[random.randint(0,2)]
            await self.channel.send(&#34;C&#39;est interdit, le choix sera aléatoire&#34;)
        if choix[0]== 0:#on sauve
            game.night_death.pop(0)
            self.heal=False
            await self.channel.send(&#34;Tu es une personne bien, la victime survivra.&#34;)
        elif choix[0] == 1: #on tue
            message=&#34;Tu veux donc tuer quelqu&#39;un, qui va devoir boire ta fameuse potion ??:\n&#34;
            i=0
            for j in non_sorciere:
                message=message+ emoji[i] + j.user.name+&#39;\n&#39;
                i=i+1
            message_sorciere = await self.channel.send(message)
    
            for j in range(0,i):
                await message_sorciere.add_reaction(emoji[j])
            await message_sorciere.add_reaction(&#39;✅&#39;)
            try:
                await bot.wait_for(&#34;reaction_add&#34;, timeout=1*60, check=checkSosoAction)
            except asyncio.TimeoutError:
                await self.channel.send(&#34;Le temps est dépassé, le choix sera aléatoire&#34;)
                mort_soso.append(random.randint(0,len(non_sorciere)))
            cache_msg = await message_sorciere.channel.fetch_message(message_sorciere.id)
            i=-1
            for reactions in cache_msg.reactions:
                i=i+1
                user_list = [user async for user in reactions.users() if user != bot.user]
                
                for user in user_list:
                    if user == sorciere.user and i &lt; len(non_sorciere):
                        mort_soso.append(i)
            if (len(mort_soso)!=1):
                mort_soso.append(random.randint(0,len(non_sorciere)))
            mort_soso=non_sorciere[mort_soso[0]]
            await self.channel.send(&#34;Très bien, &#34;+mort_soso.user.name+&#34; va mourir&#34;)
            self.kill=False
    elif len(game.night_death)==1 and self.heal==True and self.kill==False:
        mort_loup=game.night_death[0].user
        mes=sorciere.user.mention+&#34; Salut sorcière cette nuit, quelqu&#39;un va mourir. Il s&#39;agit de **&#34;+mort_loup.name+&#34;** tu as le choix entre:\n    ⚕️ la ressuciter\n    💤 ne rien faire&#34;
        message_sorciere=await self.channel.send(mes)
        await message_sorciere.add_reaction(&#39;⚕️&#39;)
        await message_sorciere.add_reaction(&#39;💤&#39;)
        await message_sorciere.add_reaction(&#39;✅&#39;)
        
        choix=[]
        def checkSosoAction(reaction,user):
            if user == sorciere.user and reaction.message.id == message_sorciere.id and str(reaction.emoji) == &#39;✅&#39; :
                return(True)
            return(False)
        try:
            await bot.wait_for(&#34;reaction_add&#34;, timeout=1*60, check=checkSosoAction)
            cache_msg = await message_sorciere.channel.fetch_message(message_sorciere.id)
            i=-1
            for reactions in cache_msg.reactions:
                i=i+1
                user_list = [user async for user in reactions.users() if user != bot.user]
                
                for user in user_list:
                    if user==sorciere.user and i &lt; 2:
                        choix.append(i)
        except asyncio.TimeoutError:
            await self.channel.send(&#34;Le temps est dépassé, le choix sera aléatoire&#34;)
            choix=[random.randint(0,1)]
        if len(choix) !=1:
            choix=[random.randint(0,1)]
            await self.channel.send(&#34;C&#39;est interdit, le choix sera aléatoire&#34;)
        if choix[0]== 0:#on sauve
            un_mort_loup=False
            await self.channel.send(&#34;Tu es une personne bien, la victime survivra.&#34;)
            self.heal=False
    elif self.kill == True:
        mes=sorciere.user.mention+&#34; Salut sorcière, tu as le choix entre:\n    💀 tuer quelqu&#39;un\n    💤 ne rien faire&#34;
        message_sorciere=await self.channel.send(mes)
        await message_sorciere.add_reaction(&#39;💀&#39;)
        await message_sorciere.add_reaction(&#39;💤&#39;)
        await message_sorciere.add_reaction(&#39;✅&#39;)
        
        choix=[]
        def checkSosoAction(reaction,user):
            if user == sorciere.user and reaction.message.id == message_sorciere.id and str(reaction.emoji) == &#39;✅&#39; :
                return(True)
            return(False)
        try:
            await bot.wait_for(&#34;reaction_add&#34;, timeout=1*60, check=checkSosoAction)
            cache_msg = await message_sorciere.channel.fetch_message(message_sorciere.id)
            i=-1
            for reactions in cache_msg.reactions:
                i=i+1
                user_list = [user async for user in reactions.users() if user != bot.user]
                
                for user in user_list:
                    if user==sorciere.user and i &lt; 2:
                        choix.append(i)
        except asyncio.TimeoutError:
            await self.channel.send(&#34;Le temps est dépasser, le choix sera aléatoire&#34;)
            choix=[random.randint(0,1)]
        if len(choix) !=1:
            choix=[random.randint(0,1)]
            await self.channel.send(&#34;C&#39;est interdit, le choix sera aléatoire&#34;)
        if choix[0] == 0: #on tue
            message=&#34;Tu veux donc tuer quelqu&#39;un, qui va devoir boire ta fameuse potion ??:\n&#34;
            i=0
            for j in non_sorciere:
                message=message+ emoji[i] + j.user.name+&#39;\n&#39;
                i=i+1
            message_sorciere = await self.channel.send(message)
    
            for j in range(0,i):
                await message_sorciere.add_reaction(emoji[j])
            await message_sorciere.add_reaction(&#39;✅&#39;)
            
            try:
                await bot.wait_for(&#34;reaction_add&#34;, timeout=1*60, check=checkSosoAction)
            except asyncio.TimeoutError:
                await self.channel.send(&#34;Le temps est dépassé, le choix sera aléatoire&#34;)
                mort_soso.append(random.randint(0,len(non_sorciere)))
            cache_msg = await message_sorciere.channel.fetch_message(message_sorciere.id)
            i=-1
            for reactions in cache_msg.reactions:
                i=i+1
                user_list = [user async for user in reactions.users() if user != bot.user]
                
                for user in user_list:
                    if user == sorciere.user and i &lt; len(non_sorciere):
                        mort_soso.append(i)
            if (len(mort_soso)!=1):
                mort_soso.append(random.randint(0,len(non_sorciere)))
            mort_soso=non_sorciere[mort_soso[0]]
            await self.channel.send(&#34;Très bien, &#34;+mort_soso.user.name+&#34; va mourir&#34;)
            self.kill=False
            game.night_death.append(mort_soso)
    await self.channel.send(&#34;Bonne nuit la sorcière&#34;)</code></pre>
</details>
</dd>
<dt id="botclass.Sorcière.jour"><code class="name flex">
<span>async def <span class="ident">jour</span></span>(<span>self, channel_public_place, user)</span>
</code></dt>
<dd>
<div class="desc"><p>set the role for the day
The Witch can speak during the day in the public channel</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>channel_public_place</code></strong> :&ensp;<code>class discord.TextChannel</code></dt>
<dd>the public channel of the current game</dd>
<dt><strong><code>user</code></strong> :&ensp;<code>class discord.User</code></dt>
<dd>The user concerned</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def jour(self,channel_public_place,user):
    &#34;&#34;&#34;set the role for the day
    The Witch can speak during the day in the public channel

    Args:
        channel_public_place (class discord.TextChannel): the public channel of the current game
        user (class discord.User): The user concerned
    &#34;&#34;&#34;
    await channel_public_place.set_permissions(user,read_messages=True,send_messages=True)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="botclass.Villageois"><code class="flex name class">
<span>class <span class="ident">Villageois</span></span>
<span>(</span><span>channel)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents the Villager 'Role'
Composed by :
name (String): the name of the 'Role'
channel (class discord.TextChannel): channel links to the player
side (int): 1 if the role is for the village, -1 if not, 0 if neutral</p>
<p>Initializes the Villager.
He is with the Village</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code>class discord.TextChannel</code></dt>
<dd>channel links to the player</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Villageois(Role):
    &#34;&#34;&#34;
    Represents the Villager &#39;Role&#39;
    Composed by :
        name (String): the name of the &#39;Role&#39;
        channel (class discord.TextChannel): channel links to the player
        side (int): 1 if the role is for the village, -1 if not, 0 if neutral
    &#34;&#34;&#34;
    
    def __init__(self,channel):
        &#34;&#34;&#34;Initializes the Villager.
        He is with the Village

        Args:
            channel (class discord.TextChannel): channel links to the player
        &#34;&#34;&#34;
        self.name=&#34;Villageois&#34;
        self.channel=channel
        self.side=1
    async def jour(self,channel_public_place,user):
        &#34;&#34;&#34;set the role for the day
        The Villager can speak during the day in the public channel

        Args:
            channel_public_place (class discord.TextChannel): the public channel of the current game
            user (class discord.User): The user concerned
        &#34;&#34;&#34;
        await channel_public_place.set_permissions(user,read_messages=True,send_messages=True)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="botclass.Role" href="#botclass.Role">Role</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="botclass.Villageois.jour"><code class="name flex">
<span>async def <span class="ident">jour</span></span>(<span>self, channel_public_place, user)</span>
</code></dt>
<dd>
<div class="desc"><p>set the role for the day
The Villager can speak during the day in the public channel</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>channel_public_place</code></strong> :&ensp;<code>class discord.TextChannel</code></dt>
<dd>the public channel of the current game</dd>
<dt><strong><code>user</code></strong> :&ensp;<code>class discord.User</code></dt>
<dd>The user concerned</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def jour(self,channel_public_place,user):
    &#34;&#34;&#34;set the role for the day
    The Villager can speak during the day in the public channel

    Args:
        channel_public_place (class discord.TextChannel): the public channel of the current game
        user (class discord.User): The user concerned
    &#34;&#34;&#34;
    await channel_public_place.set_permissions(user,read_messages=True,send_messages=True)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="botclass.Voyante"><code class="flex name class">
<span>class <span class="ident">Voyante</span></span>
<span>(</span><span>channel)</span>
</code></dt>
<dd>
<div class="desc"><p>Represents the Clairvoyant 'Role'
Composed by :
name (String): the name of the 'Role'
channel (class discord.TextChannel): channel links to the player
side (int): 1 if the role is for the village, -1 if not, 0 if neutral</p>
<p>Initializes Clairvoyant.
He is with the Village</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>channel</code></strong> :&ensp;<code>class discord.TextChannel</code></dt>
<dd>channel links to the player</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Voyante(Role):
    &#34;&#34;&#34;
    Represents the Clairvoyant &#39;Role&#39;
    Composed by :
        name (String): the name of the &#39;Role&#39;
        channel (class discord.TextChannel): channel links to the player
        side (int): 1 if the role is for the village, -1 if not, 0 if neutral
    &#34;&#34;&#34;
    
    def __init__(self,channel):
        &#34;&#34;&#34;Initializes Clairvoyant.
        He is with the Village

        Args:
            channel (class discord.TextChannel): channel links to the player
        &#34;&#34;&#34;
        self.name=&#34;Voyante&#34;
        self.channel=channel
        self.side=1
    async def action(self,voyante,game,bot):
        &#34;&#34;&#34;start the turn of Clairvoyant.
        She can discover the role of one Player each nigth
        Args:
            game (class Game): The current game party
            bot (class Bot): The current bot
            
        return: Nothing
        &#34;&#34;&#34;
        non_voyante=[]
        players=game.players
        for player in players:
            if player != voyante and player.is_alive:
                non_voyante.append(player)
    
        message=&#34;&#34;
        i=0
        for player in non_voyante:
            message=message+ emoji[i] + player.user.name+&#39;\n&#39;
            i=i+1

        message_voyante=await self.channel.send(voyante.user.mention+&#34;! Salut Voyante, tu dois choisir qui tu veux voir cette nuit:\n&#34;+message)
        def checkVoyante(reaction,user):
            if user==voyante.user and reaction.message.id == message_voyante.id and (str(reaction.emoji) == &#39;✅&#39; or str(reaction.emoji) ==&#39;❌&#39;):
                return(True)
            return(False)

        for j in range(0,i):
            await message_voyante.add_reaction(emoji[j])
        await message_voyante.add_reaction(&#39;✅&#39;)
        vision=[]
        try:
            await bot.wait_for(&#34;reaction_add&#34;, timeout=60, check=checkVoyante)
        except asyncio.TimeoutError:
            await self.channel.send(&#34;Le temps est dépassé ou le choix est erroné, le choix sera donc aléatoire&#34;)
        cache_msg = await message_voyante.channel.fetch_message(message_voyante.id)
        i=-1
        
        for reactions in cache_msg.reactions:
            i=i+1
            user_list = [user async for user in reactions.users() if user != bot.user]
            
            for user in user_list:
                if user==voyante.user and i &lt; len(non_voyante):
                    vision.append(non_voyante[i])
        if len(vision) !=1:
            vision=[non_voyante[random.randint(0,len(non_voyante)-1)]]
        mes=&#34;Tu as décidé de voir &#34;+vision[0].user.name+ &#34; qui est &#34;+vision[0].role.name

        await self.channel.send(mes)
    async def jour(self,channel_public_place,user):
        &#34;&#34;&#34;set the role for the day
        Cupidon can speak during the day in the public channel.

        Args:
            channel_public_place (class discord.TextChannel): the public channel of the current game
            user (class discord.User): The user concerned
        &#34;&#34;&#34;
        await channel_public_place.set_permissions(user,read_messages=True,send_messages=True)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="botclass.Role" href="#botclass.Role">Role</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="botclass.Voyante.action"><code class="name flex">
<span>async def <span class="ident">action</span></span>(<span>self, voyante, game, bot)</span>
</code></dt>
<dd>
<div class="desc"><p>start the turn of Clairvoyant.
She can discover the role of one Player each nigth</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>game</code></strong> :&ensp;<code>class <a title="botclass.Game" href="#botclass.Game">Game</a></code></dt>
<dd>The current game party</dd>
<dt><strong><code>bot</code></strong> :&ensp;<code>class Bot</code></dt>
<dd>The current bot</dd>
</dl>
<p>return: Nothing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def action(self,voyante,game,bot):
    &#34;&#34;&#34;start the turn of Clairvoyant.
    She can discover the role of one Player each nigth
    Args:
        game (class Game): The current game party
        bot (class Bot): The current bot
        
    return: Nothing
    &#34;&#34;&#34;
    non_voyante=[]
    players=game.players
    for player in players:
        if player != voyante and player.is_alive:
            non_voyante.append(player)

    message=&#34;&#34;
    i=0
    for player in non_voyante:
        message=message+ emoji[i] + player.user.name+&#39;\n&#39;
        i=i+1

    message_voyante=await self.channel.send(voyante.user.mention+&#34;! Salut Voyante, tu dois choisir qui tu veux voir cette nuit:\n&#34;+message)
    def checkVoyante(reaction,user):
        if user==voyante.user and reaction.message.id == message_voyante.id and (str(reaction.emoji) == &#39;✅&#39; or str(reaction.emoji) ==&#39;❌&#39;):
            return(True)
        return(False)

    for j in range(0,i):
        await message_voyante.add_reaction(emoji[j])
    await message_voyante.add_reaction(&#39;✅&#39;)
    vision=[]
    try:
        await bot.wait_for(&#34;reaction_add&#34;, timeout=60, check=checkVoyante)
    except asyncio.TimeoutError:
        await self.channel.send(&#34;Le temps est dépassé ou le choix est erroné, le choix sera donc aléatoire&#34;)
    cache_msg = await message_voyante.channel.fetch_message(message_voyante.id)
    i=-1
    
    for reactions in cache_msg.reactions:
        i=i+1
        user_list = [user async for user in reactions.users() if user != bot.user]
        
        for user in user_list:
            if user==voyante.user and i &lt; len(non_voyante):
                vision.append(non_voyante[i])
    if len(vision) !=1:
        vision=[non_voyante[random.randint(0,len(non_voyante)-1)]]
    mes=&#34;Tu as décidé de voir &#34;+vision[0].user.name+ &#34; qui est &#34;+vision[0].role.name

    await self.channel.send(mes)</code></pre>
</details>
</dd>
<dt id="botclass.Voyante.jour"><code class="name flex">
<span>async def <span class="ident">jour</span></span>(<span>self, channel_public_place, user)</span>
</code></dt>
<dd>
<div class="desc"><p>set the role for the day
Cupidon can speak during the day in the public channel.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>channel_public_place</code></strong> :&ensp;<code>class discord.TextChannel</code></dt>
<dd>the public channel of the current game</dd>
<dt><strong><code>user</code></strong> :&ensp;<code>class discord.User</code></dt>
<dd>The user concerned</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def jour(self,channel_public_place,user):
    &#34;&#34;&#34;set the role for the day
    Cupidon can speak during the day in the public channel.

    Args:
        channel_public_place (class discord.TextChannel): the public channel of the current game
        user (class discord.User): The user concerned
    &#34;&#34;&#34;
    await channel_public_place.set_permissions(user,read_messages=True,send_messages=True)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="botclass.Chasseur" href="#botclass.Chasseur">Chasseur</a></code></h4>
<ul class="">
<li><code><a title="botclass.Chasseur.action" href="#botclass.Chasseur.action">action</a></code></li>
<li><code><a title="botclass.Chasseur.jour" href="#botclass.Chasseur.jour">jour</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="botclass.Cupidon" href="#botclass.Cupidon">Cupidon</a></code></h4>
<ul class="">
<li><code><a title="botclass.Cupidon.action" href="#botclass.Cupidon.action">action</a></code></li>
<li><code><a title="botclass.Cupidon.jour" href="#botclass.Cupidon.jour">jour</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="botclass.Game" href="#botclass.Game">Game</a></code></h4>
<ul class="two-column">
<li><code><a title="botclass.Game.check_end" href="#botclass.Game.check_end">check_end</a></code></li>
<li><code><a title="botclass.Game.check_lover" href="#botclass.Game.check_lover">check_lover</a></code></li>
<li><code><a title="botclass.Game.check_mayor" href="#botclass.Game.check_mayor">check_mayor</a></code></li>
<li><code><a title="botclass.Game.def_lover" href="#botclass.Game.def_lover">def_lover</a></code></li>
<li><code><a title="botclass.Game.define_mayor" href="#botclass.Game.define_mayor">define_mayor</a></code></li>
<li><code><a title="botclass.Game.finish" href="#botclass.Game.finish">finish</a></code></li>
<li><code><a title="botclass.Game.initialize" href="#botclass.Game.initialize">initialize</a></code></li>
<li><code><a title="botclass.Game.is_started" href="#botclass.Game.is_started">is_started</a></code></li>
<li><code><a title="botclass.Game.jour" href="#botclass.Game.jour">jour</a></code></li>
<li><code><a title="botclass.Game.loups" href="#botclass.Game.loups">loups</a></code></li>
<li><code><a title="botclass.Game.nuit" href="#botclass.Game.nuit">nuit</a></code></li>
<li><code><a title="botclass.Game.start" href="#botclass.Game.start">start</a></code></li>
<li><code><a title="botclass.Game.vote" href="#botclass.Game.vote">vote</a></code></li>
<li><code><a title="botclass.Game.without_mayor" href="#botclass.Game.without_mayor">without_mayor</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="botclass.Joueur" href="#botclass.Joueur">Joueur</a></code></h4>
<ul class="">
<li><code><a title="botclass.Joueur.is_alive" href="#botclass.Joueur.is_alive">is_alive</a></code></li>
<li><code><a title="botclass.Joueur.kill" href="#botclass.Joueur.kill">kill</a></code></li>
<li><code><a title="botclass.Joueur.nuit" href="#botclass.Joueur.nuit">nuit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="botclass.Loup" href="#botclass.Loup">Loup</a></code></h4>
<ul class="">
<li><code><a title="botclass.Loup.jour" href="#botclass.Loup.jour">jour</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="botclass.Lover" href="#botclass.Lover">Lover</a></code></h4>
<ul class="">
<li><code><a title="botclass.Lover.check_death" href="#botclass.Lover.check_death">check_death</a></code></li>
<li><code><a title="botclass.Lover.jour" href="#botclass.Lover.jour">jour</a></code></li>
<li><code><a title="botclass.Lover.nuit" href="#botclass.Lover.nuit">nuit</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="botclass.Petite_fille" href="#botclass.Petite_fille">Petite_fille</a></code></h4>
<ul class="">
<li><code><a title="botclass.Petite_fille.action" href="#botclass.Petite_fille.action">action</a></code></li>
<li><code><a title="botclass.Petite_fille.jour" href="#botclass.Petite_fille.jour">jour</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="botclass.Role" href="#botclass.Role">Role</a></code></h4>
</li>
<li>
<h4><code><a title="botclass.Salvateur" href="#botclass.Salvateur">Salvateur</a></code></h4>
<ul class="">
<li><code><a title="botclass.Salvateur.action" href="#botclass.Salvateur.action">action</a></code></li>
<li><code><a title="botclass.Salvateur.jour" href="#botclass.Salvateur.jour">jour</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="botclass.Soeur" href="#botclass.Soeur">Soeur</a></code></h4>
<ul class="">
<li><code><a title="botclass.Soeur.jour" href="#botclass.Soeur.jour">jour</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="botclass.Sorcière" href="#botclass.Sorcière">Sorcière</a></code></h4>
<ul class="">
<li><code><a title="botclass.Sorcière.action" href="#botclass.Sorcière.action">action</a></code></li>
<li><code><a title="botclass.Sorcière.jour" href="#botclass.Sorcière.jour">jour</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="botclass.Villageois" href="#botclass.Villageois">Villageois</a></code></h4>
<ul class="">
<li><code><a title="botclass.Villageois.jour" href="#botclass.Villageois.jour">jour</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="botclass.Voyante" href="#botclass.Voyante">Voyante</a></code></h4>
<ul class="">
<li><code><a title="botclass.Voyante.action" href="#botclass.Voyante.action">action</a></code></li>
<li><code><a title="botclass.Voyante.jour" href="#botclass.Voyante.jour">jour</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>